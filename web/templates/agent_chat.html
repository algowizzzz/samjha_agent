{% extends "base.html" %}
{% block title %}MR Limits AI assisted analysis{% endblock %}

{% block extra_css %}
<!-- Cache prevention meta tags - VERSION 9 -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<meta name="version" content="9">
<!-- Markdown CSS for better formatting -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.2.0/github-markdown.min.css">
<style>
    /* Full screen layout - override all Bootstrap defaults */
    html {
        height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    body {
        overflow: hidden !important;
        height: 100vh !important;
        margin: 0 !important;
        padding: 0 !important;
        width: 100% !important;
        display: flex !important;
        flex-direction: column !important;
        background-color: #f8f9fa !important;
    }
    /* Hide footer completely */
    footer.footer {
        display: none !important;
    }
    /* Make main container fill viewport minus navbar */
    main.container-fluid {
        margin: 0 !important;
        padding: 0 !important;
        flex: 1 !important;
        height: auto !important;
        min-height: 0 !important;
        max-width: 100% !important;
        width: 100% !important;
        overflow: hidden !important;
    }
    /* Override Bootstrap py-4 padding class */
    main.container-fluid.py-4 {
        padding: 0 !important;
    }
    /* Override any container constraints */
    .container, .container-fluid {
        max-width: 100% !important;
        width: 100% !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
        padding-top: 0 !important;
        padding-bottom: 0 !important;
    }
    /* Remove all margins and padding from content wrapper */
    main > div:first-child {
        margin: 0 !important;
        padding: 0 !important;
        width: 100% !important;
        height: 100% !important;
    }
    /* Remove card margins and ensure full width */
    .card {
        margin: 0 !important;
        margin-bottom: 0 !important;
        width: 100% !important;
        border-radius: 0 !important;
    }
    /* Remove shadow for edge-to-edge */
    .card.shadow-sm {
        box-shadow: none !important;
    }
    
    .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 100%;
        margin: 0;
        padding: 15px;
        font-size: 14px;
        background-color: white !important;
        color: #333 !important;
    }
    /* Compact spacing for welcome message */
    .chat-message.agent .markdown-body h2 {
        margin-top: 16px;
        margin-bottom: 8px;
        font-size: 16px;
    }
    .chat-message.agent .markdown-body h2:first-of-type {
        margin-top: 8px;
    }
    .chat-message.agent .markdown-body h3 {
        margin-top: 12px;
        margin-bottom: 6px;
        font-size: 14px;
    }
    .chat-message.agent .markdown-body p {
        margin-top: 6px;
        margin-bottom: 6px;
    }
    .chat-message.agent .markdown-body ul {
        margin-top: 4px;
        margin-bottom: 8px;
    }
    .chat-message.agent .markdown-body li {
        margin-bottom: 2px;
    }
    .chat-message.agent .markdown-body blockquote {
        margin-top: 6px;
        margin-bottom: 6px;
        padding: 6px 12px;
        font-size: 13px;
    }
    .markdown-body * {
        color: #333 !important;
    }
    .markdown-body pre {
        background-color: #f6f8fa;
        border-radius: 6px;
        padding: 16px;
        overflow: auto;
        color: #333 !important;
    }
    .markdown-body code {
        background-color: rgba(175, 184, 193, 0.2);
        padding: 2px 4px;
        border-radius: 3px;
        font-size: 85%;
        color: #333 !important;
    }
    .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
        color: #333 !important;
    }
    .chat-message {
        padding: 12px 16px;
        border-radius: 8px;
        margin-bottom: 12px;
        max-width: 85%;
    }
    .chat-message.user {
        background-color: #e9ecef;
        margin-left: auto;
        text-align: right;
    }
    .chat-message.agent {
        background-color: white;
        border: 1px solid #dee2e6;
        margin-right: auto;
        color: #333;
    }
    .table-container {
        position: relative;
    }
    .table-search {
        margin-bottom: 10px;
    }
    .prompt-monitor-content {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.4;
        font-size: 13px;
    }
    /* Make headers small and compact - no large headers in prompt monitor */
    .prompt-monitor-content h1, .prompt-monitor-content h2, .prompt-monitor-content h3 {
        margin-top: 8px;
        margin-bottom: 4px;
        font-weight: 600;
        font-size: 14px; /* Same size as body text */
    }
    .prompt-monitor-content h1 {
        font-size: 14px; /* h1 same as body */
    }
    .prompt-monitor-content h2 {
        font-size: 13px; /* h2 slightly smaller */
    }
    .prompt-monitor-content ul, .prompt-monitor-content ol {
        margin-top: 4px;
        margin-bottom: 4px;
        padding-left: 20px;
    }
    .prompt-monitor-content li {
        margin-bottom: 3px;
    }
    .prompt-monitor-content p {
        margin-top: 4px;
        margin-bottom: 4px;
    }
    .prompt-monitor-content code {
        background-color: #f4f4f4;
        padding: 2px 6px;
        border-radius: 3px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
    }
    .prompt-monitor-content strong {
        font-weight: 600;
    }
    
    /* Loading states and animations */
    .loading-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        color: #6c757d;
        font-size: 14px;
        animation: fadeIn 0.2s ease-in;
    }
    
    .typing-indicator {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        color: #6c757d;
        font-size: 13px;
        font-style: italic;
    }
    
    .typing-dots {
        display: inline-flex;
        gap: 3px;
    }
    
    .typing-dots span {
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background-color: #6c757d;
        animation: typingPulse 1.4s infinite;
    }
    
    .typing-dots span:nth-child(2) {
        animation-delay: 0.2s;
    }
    
    .typing-dots span:nth-child(3) {
        animation-delay: 0.4s;
    }
    
    /* Node Progress Status */
    .node-progress-container {
        font-size: 12px;
        color: #6c757d;
        padding: 8px 12px;
        margin-top: 8px;
        margin-bottom: 8px;
        background-color: #f8f9fa;
        border-left: 3px solid #0d6efd;
        border-radius: 4px;
    }
    
    .node-progress-item {
        display: flex;
        align-items: flex-start;
        padding: 4px 0;
        margin: 2px 0;
    }
    
    .node-progress-item .node-icon {
        margin-right: 8px;
        margin-top: 2px;
        flex-shrink: 0;
    }
    
    .node-progress-item .node-content {
        flex: 1;
    }
    
    .node-progress-item .node-name {
        font-weight: 500;
        color: #495057;
        margin-bottom: 2px;
    }
    
    .node-progress-item .node-reasoning {
        font-size: 11px;
        color: #6c757d;
        font-style: italic;
    }
    
    .node-progress-item.active .node-name {
        color: #0d6efd;
    }
    
    .node-progress-item.completed .node-name {
        color: #198754;
    }
    
    .node-progress-item.error .node-name {
        color: #dc3545;
    }
    
    /* Animations */
    @keyframes fadeIn {
        from {
            opacity: 0;
        }
        to {
            opacity: 1;
        }
    }
    
    @keyframes fadeOut {
        from {
            opacity: 1;
        }
        to {
            opacity: 0;
        }
    }
    
    @keyframes slideInDown {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    @keyframes typingPulse {
        0%, 60%, 100% {
            opacity: 0.3;
            transform: scale(0.8);
        }
        30% {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    .message-fade-in {
        animation: fadeIn 0.3s ease-in;
    }
    
    .content-smooth {
        transition: all 0.2s ease;
    }
    
    /* Error state styling */
    .error-message {
        background-color: #f8d7da;
        border-color: #f5c2c7;
        color: #842029;
    }
    
    /* Mobile responsive status bar */
    @media (max-width: 768px) {
        .status-bar {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }
        
        .status-step:not(:last-child)::after {
            display: none;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="p-0 m-0" style="height: 100%; width: 100%; display: flex; flex-direction: column; margin: 0 !important; padding: 0 !important;">
    <div class="card shadow-sm h-100 d-flex flex-column m-0" style="border-radius: 0; border: none; height: 100%; margin: 0 !important; width: 100%;">
        <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center" style="flex-shrink: 0;">
            <h5 class="mb-0"><i class="bi bi-chat-text"></i> MR Limits AI assisted analysis</h5>
            <div class="d-flex align-items-center gap-2 flex-wrap">
                <div class="d-flex align-items-center gap-2" style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">
                    <label for="dataDictSelect" class="mb-0 text-white" style="font-size: 11px; white-space: nowrap;">Database business instructions:</label>
                    <select id="dataDictSelect" class="form-select form-select-sm" style="width: auto; min-width: 180px; font-size: 11px;">
                        <option value="">Loading...</option>
                    </select>
                    <label for="dataDictUpload" class="btn btn-sm btn-light mb-0" style="cursor: pointer; padding: 2px 6px; font-size: 11px;" title="Upload data dictionary">
                        <i class="bi bi-upload"></i>
                    </label>
                    <input type="file" id="dataDictUpload" accept=".json" style="display: none;">
                </div>
                <div class="d-flex align-items-center gap-2" style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">
                    <label for="agentPromptsSelect" class="mb-0 text-white" style="font-size: 11px; white-space: nowrap;">Agent Prompts:</label>
                    <select id="agentPromptsSelect" class="form-select form-select-sm" style="width: auto; min-width: 180px; font-size: 11px;">
                        <option value="">Loading...</option>
                    </select>
                    <label for="agentPromptsUpload" class="btn btn-sm btn-light mb-0" style="cursor: pointer; padding: 2px 6px; font-size: 11px;" title="Upload agent prompts">
                        <i class="bi bi-upload"></i>
                    </label>
                    <input type="file" id="agentPromptsUpload" accept=".json" style="display: none;">
                </div>
                <div class="d-flex align-items-center gap-2" style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">
                    <label for="welcomeTipsSelect" class="mb-0 text-white" style="font-size: 11px; white-space: nowrap;">Welcome Tips:</label>
                    <select id="welcomeTipsSelect" class="form-select form-select-sm" style="width: auto; min-width: 180px; font-size: 11px;">
                        <option value="">Loading...</option>
                    </select>
                    <label for="welcomeTipsUpload" class="btn btn-sm btn-light mb-0" style="cursor: pointer; padding: 2px 6px; font-size: 11px;" title="Upload welcome tips">
                        <i class="bi bi-upload"></i>
                    </label>
                    <input type="file" id="welcomeTipsUpload" accept=".json" style="display: none;">
                </div>
                <div class="d-flex align-items-center gap-2" style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">
                    <label for="agentDomain" class="mb-0 text-white" style="font-size: 11px; white-space: nowrap;">Domain:</label>
                    <input type="text" id="agentDomain" class="form-control form-control-sm" style="width: auto; min-width: 120px; font-size: 11px;" placeholder="e.g., Finance">
                </div>
                <div class="d-flex align-items-center gap-2" style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">
                    <label for="agentName" class="mb-0 text-white" style="font-size: 11px; white-space: nowrap;">Name:</label>
                    <input type="text" id="agentName" class="form-control form-control-sm" style="width: auto; min-width: 120px; font-size: 11px;" placeholder="e.g., Risk Analysis">
                </div>
                <button id="saveAgentBtn" class="btn btn-sm btn-success" title="Save agent configuration">
                    <i class="bi bi-save"></i> Save Agent
                </button>
                <button id="newChatBtn" class="btn btn-sm btn-light" title="Start a new chat session">
                    <i class="bi bi-plus-circle"></i> New Chat
                </button>
            <span class="badge bg-light text-dark">DuckDB</span>
            </div>
        </div>
        <!-- Existing Agents Section -->
        <div class="card-header bg-secondary text-white d-flex justify-content-between align-items-center" style="flex-shrink: 0; padding: 8px 16px;">
            <label for="existingAgentsSelect" class="mb-0 text-white" style="font-size: 12px; white-space: nowrap;">Existing Agents:</label>
            <div class="d-flex align-items-center gap-2">
                <select id="existingAgentsSelect" class="form-select form-select-sm" style="width: auto; min-width: 250px; font-size: 11px;">
                    <option value="">Loading agents...</option>
                </select>
                <button id="activateAgentBtn" class="btn btn-sm btn-warning" title="Activate selected agent configuration" disabled>
                    <i class="bi bi-play-circle"></i> Activate
                </button>
            </div>
        </div>
        <div class="card-body d-flex flex-column p-3" style="flex: 1; overflow: hidden; min-height: 0;">
            <div id="chatHistory" class="mb-3 flex-grow-1" style="overflow-y: auto; border: 1px solid #eee; padding: 12px; border-radius: 6px; background: #fafafa; min-height: 0;">
                <!-- Messages will be appended here -->
            </div>
            <div class="input-group" style="flex-shrink: 0;">
                <input id="chatInput" type="text" class="form-control" placeholder="Ask a question or follow up..." />
                <button id="killBtn" class="btn btn-danger" style="display: none;">
                    <i class="bi bi-x-circle"></i> Kill
                </button>
                <button id="sendBtn" class="btn btn-primary">
                    <i class="bi bi-send"></i> Send
                </button>
            </div>
            <div class="form-text mt-2" style="flex-shrink: 0;">Responses include an Answer, SQL Prompt & Results, and Prompt Monitor summary.</div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Cache buster: Version 9 - Data Analysis Agents with Domain/Name fields and Auto-activation -->
<script>
    (function() {
        // CHECK VERSION FIRST - before doing anything else
        const storedVersion = localStorage.getItem('agent_chat_version');
        if (storedVersion && storedVersion !== '9') {
            console.error('%cüö®üö®üö® VERSION ' + storedVersion + ' IN CACHE! FORCING RELOAD TO V9...', 'font-size: 20px; font-weight: bold; color: red; background: yellow; padding: 15px; border: 5px solid red;');
            // Clear ALL localStorage
            localStorage.clear();
            // Force immediate reload with cache bypass
            const url = window.location.href.split('?')[0] + '?v=9&t=' + Date.now() + '&_=' + Math.random() + '&nocache=' + Date.now();
            window.location.replace(url);
            return; // Stop execution
        }
        
        // Check if old version script already ran (window.AGENT_CHAT_VERSION exists and is not 9)
        if (window.AGENT_CHAT_VERSION && window.AGENT_CHAT_VERSION !== 9) {
            console.error('%cüö®üö®üö® OLD SCRIPT VERSION ' + window.AGENT_CHAT_VERSION + ' DETECTED! FORCING RELOAD...', 'font-size: 20px; font-weight: bold; color: red; background: yellow; padding: 15px; border: 5px solid red;');
            localStorage.clear();
            const url = window.location.href.split('?')[0] + '?v=9&t=' + Date.now() + '&_=' + Math.random() + '&nocache=' + Date.now();
            window.location.replace(url);
            return; // Stop execution
        }
        
        const VERSION = 9;
        const BUILD_TIME = Date.now();
        
        // Check for service workers and unregister them
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    registration.unregister();
                    console.log('Unregistered service worker:', registration.scope);
                }
            });
        }
        
        console.log('%cüöÄüöÄüöÄ AGENT CHAT HTML LOADED üöÄüöÄüöÄ', 'font-size: 16px; font-weight: bold; color: #0d6efd;');
        console.log('%cVERSION ' + VERSION + ' (Data Analysis Agents - Domain/Name + Auto-activation)', 'font-size: 16px; font-weight: bold; color: #ff0000; background: #ffff00; padding: 5px;');
        console.log('Timestamp:', new Date().toISOString());
        console.log('Build:', BUILD_TIME);
        console.log('%c‚ö†Ô∏è If you see VERSION 8 or earlier, your browser is caching!', 'font-size: 14px; font-weight: bold; color: red;');
        console.log('Do a hard refresh: Cmd+Shift+R (Mac) or Ctrl+Shift+R (Windows)');
        
        // Store version in window for debugging
        window.AGENT_CHAT_VERSION = VERSION;
        window.AGENT_CHAT_BUILD = BUILD_TIME;
        
        // Set version in localStorage
        localStorage.setItem('agent_chat_version', '9');
        
        // Final verification after short delay
        setTimeout(function() {
            if (window.AGENT_CHAT_VERSION !== 9) {
                console.error('%cüö®üö®üö® FINAL CHECK FAILED! Expected 9, got ' + (window.AGENT_CHAT_VERSION || 'undefined') + ' üö®üö®üö®', 'font-size: 18px; font-weight: bold; color: red; background: yellow; padding: 15px; border: 3px solid red;');
                localStorage.clear();
                const url = window.location.href.split('?')[0] + '?v=9&t=' + Date.now() + '&_=' + Math.random() + '&nocache=' + Date.now();
                window.location.replace(url);
            } else {
                console.log('%c‚úÖ‚úÖ‚úÖ CORRECT VERSION 9 DETECTED! ‚úÖ‚úÖ‚úÖ', 'font-size: 14px; font-weight: bold; color: green;');
            }
        }, 100);
    })();
</script>
<!-- Markdown Parser -->
<script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
<script>
    // Configure marked.js for GitHub Flavored Markdown (tables, etc.)
    if (typeof marked !== 'undefined') {
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: true,
            mangle: false
        });
    }
</script>
<!-- DataTables for interactive tables -->
<link rel="stylesheet" href="https://cdn.datatables.net/1.13.7/css/jquery.dataTables.min.css">
<link rel="stylesheet" href="https://cdn.datatables.net/buttons/2.4.2/css/buttons.dataTables.min.css">
<script src="https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/buttons/2.4.2/js/dataTables.buttons.min.js"></script>
<script src="https://cdn.datatables.net/buttons/2.4.2/js/buttons.html5.min.js"></script>
<script>
    // Agent Chat v5.2 - Fixed: typing indicator text bleeding into response - 2025-11-09 20:20
(function() {
    'use strict';
    // Ensure API token is available for /api/tools/execute
    const templateToken = "{{ session.token or '' }}";
    if (templateToken) {
        try {
            sessionStorage.setItem('mcp_token', templateToken);
            document.cookie = 'mcp_token=' + templateToken + '; path=/';
        } catch (e) {}
    }

    let sessionId = localStorage.getItem('agent_session_id') || '';
    if (!sessionId) {
        sessionId = 'sess-' + Math.random().toString(36).slice(2, 10);
        localStorage.setItem('agent_session_id', sessionId);
    }

    const historyEl = document.getElementById('chatHistory');
    const inputEl = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const killBtn = document.getElementById('killBtn');
    const dataDictSelect = document.getElementById('dataDictSelect');
    const dataDictUpload = document.getElementById('dataDictUpload');
    const agentPromptsSelect = document.getElementById('agentPromptsSelect');
    const agentPromptsUpload = document.getElementById('agentPromptsUpload');
    const welcomeTipsSelect = document.getElementById('welcomeTipsSelect');
    const welcomeTipsUpload = document.getElementById('welcomeTipsUpload');
    const agentDomain = document.getElementById('agentDomain');
    const agentName = document.getElementById('agentName');
    const saveAgentBtn = document.getElementById('saveAgentBtn');
    const existingAgentsSelect = document.getElementById('existingAgentsSelect');
    const activateAgentBtn = document.getElementById('activateAgentBtn');
    let isQueryRunning = false;
    
    // Default config files - clear localStorage if wrong values detected
    let storedDataDict = localStorage.getItem('selected_data_dict');
    let storedAgentPrompts = localStorage.getItem('selected_agent_prompts');
    let storedWelcomeTips = localStorage.getItem('selected_welcome_tips');
    
    // Reset if wrong file is stored (e.g., queryagent_planner.json in wrong dropdown)
    if (storedDataDict === 'queryagent_planner.json') {
        localStorage.removeItem('selected_data_dict');
        storedDataDict = null;
    }
    if (storedAgentPrompts === 'data_dictionary_risk.json' || storedAgentPrompts === 'agent_welcome_message.json') {
        localStorage.removeItem('selected_agent_prompts');
        storedAgentPrompts = null;
    }
    if (storedWelcomeTips === 'queryagent_planner.json' || storedWelcomeTips === 'data_dictionary_risk.json') {
        localStorage.removeItem('selected_welcome_tips');
        storedWelcomeTips = null;
    }
    
    let selectedDataDict = storedDataDict || 'data_dictionary_risk.json';
    let selectedAgentPrompts = storedAgentPrompts || 'queryagent_planner.json';
    let selectedWelcomeTips = storedWelcomeTips || 'agent_welcome_message.json';

    // SocketIO connection for streaming
    let socket = null;
    let currentStreamingNode = null;
    let currentResponseId = null;
    let currentPromptMonitorId = null;
    let isUserScrolling = false;
    let accumulatedText = {
        planner: '',
        evaluator: '',
        end_response: '',
        end_prompt_monitor: ''
    };
    
    // ====================================================================================
    // PHASE 1: Node Progress Status (Bottom Status Bar)
    // ====================================================================================
    
    const completedNodes = new Set();
    let activeNode = null;
    const nodeDataStore = {}; // Store data and reasoning for each node
    
    function formatNodeName(nodeName) {
        // Convert node names to user-friendly format
        const nodeNames = {
            'invoke': 'Starting',
            'check_followup': 'Checking context',
            'check_data_sufficiency': 'Assessing data needs',
            'check_structure': 'Understanding request',
            'check_ambiguity': 'Reviewing clarity',
            'clarify': 'Asking for clarification',
            'process_clarification': 'Processing response',
            'generate_sql': 'Building query',
            'execute_sql': 'Running query',
            'retry_sql': 'Retrying query',
            'synthesize': 'Preparing answer',
            'end': 'Complete'
        };
        return nodeNames[nodeName] || nodeName;
    }
    
    function getNodeReasoning(node, nodeData) {
        // Get reasoning message, replacing "query" with "prompt"
        if (nodeData && nodeData.node_reasoning) {
            return nodeData.node_reasoning.replace(/query/gi, 'prompt').replace(/Query/gi, 'Prompt');
        }
        
        // Fallback: generate a simple description based on node data
        if (!nodeData) return '';
        
        const parts = [];
        if (node === 'invoke') {
            if (nodeData.has_table_schema) parts.push('Schema loaded');
            if (nodeData.has_conversation_history) parts.push('History loaded');
        } else if (node === 'check_followup') {
            parts.push(nodeData.is_followup ? 'Prompt detected as follow-up prompt' : 'Prompt detected as new prompt');
        } else if (node === 'check_data_sufficiency') {
            parts.push(nodeData.more_data_needed ? 'More data needed' : 'Filter only');
        } else if (node === 'check_structure') {
            parts.push(nodeData.is_structured ? 'Prompt classified as structured' : 'Prompt classified as knowledge');
        } else if (node === 'check_ambiguity') {
            if (nodeData.is_ambiguous) {
                const qCount = (nodeData.clarification_questions || []).length;
                parts.push(`Needs clarification (${qCount} questions)`);
            } else {
                parts.push('Prompt is clear');
            }
        } else if (node === 'generate_sql') {
            if (nodeData.plan_quality) parts.push(`Quality: ${nodeData.plan_quality}`);
        } else if (node === 'execute_sql' || node === 'synthesize') {
            const rowCount = nodeData.raw_table?.row_count || 0;
            if (rowCount > 0) parts.push(`${rowCount} rows returned`);
        } else if (node === 'end') {
            const rowCount = nodeData.raw_table?.row_count || 0;
            if (rowCount > 0) parts.push(`Completed with ${rowCount} rows`);
        }
        
        return parts.join(', ');
    }
    
    function updateNodeProgressStatus() {
        // First, remove any progress containers that are NOT inside user message wrappers
        // This ensures old containers at the bottom are removed
        const historyEl = document.getElementById('chatHistory');
        if (historyEl) {
            const allProgressContainers = historyEl.querySelectorAll('.node-progress-container');
            allProgressContainers.forEach(container => {
                const wrapper = container.closest('.mb-3');
                const userMessage = wrapper?.querySelector('.chat-message.user');
                if (!userMessage) {
                    console.log('[updateNodeProgressStatus] Removing orphaned progress container');
                    container.remove();
                }
            });
        }
        
        // Find the last user message to attach the status to
        if (!historyEl) {
            console.warn('[updateNodeProgressStatus] chatHistory not found');
            return;
        }
        
        // Find the last user message wrapper
        const userMessages = Array.from(historyEl.querySelectorAll('.chat-message.user'));
        if (userMessages.length === 0) {
            console.warn('[updateNodeProgressStatus] No user messages found');
            return;
        }
        
        const lastUserMessage = userMessages[userMessages.length - 1];
        const wrapper = lastUserMessage.closest('.mb-3');
        if (!wrapper) {
            console.warn('[updateNodeProgressStatus] Could not find wrapper for user message');
            return;
        }
        
        // Find or create the node progress container
        let progressContainer = wrapper.querySelector('.node-progress-container');
        if (!progressContainer) {
            console.log('[updateNodeProgressStatus] Creating new progress container after user message');
            progressContainer = document.createElement('div');
            progressContainer.className = 'node-progress-container';
            wrapper.appendChild(progressContainer);
        }
        
        // Make sure it's visible
        progressContainer.style.display = 'block';
        
        // All possible nodes in order
        const allNodes = ['invoke', 'check_followup', 'check_data_sufficiency', 'check_structure', 
                         'check_ambiguity', 'generate_sql', 'execute_sql', 'synthesize', 'end'];
        
        // Only show nodes that have been started (completed or active)
        const visibleNodes = allNodes.filter(node => completedNodes.has(node) || activeNode === node);
        
        if (visibleNodes.length === 0 && !activeNode) {
            progressContainer.innerHTML = '<span class="text-muted">Waiting...</span>';
            return;
        }
        
        const statusItems = visibleNodes.map(node => {
            const nodeData = nodeDataStore[node] || {};
            const nodeName = formatNodeName(node);
            const reasoning = getNodeReasoning(node, nodeData);
            let className = 'node-progress-item';
            let icon = '';
            
            if (completedNodes.has(node)) {
                className += ' completed';
                icon = '<i class="bi bi-check-circle-fill node-icon" style="color: #198754; font-size: 12px;"></i>';
            } else if (activeNode === node) {
                className += ' active';
                icon = '<i class="bi bi-arrow-repeat spinner-border spinner-border-sm node-icon" style="width: 12px; height: 12px; color: #0d6efd;"></i>';
            } else {
                icon = '<i class="bi bi-circle node-icon" style="color: #dee2e6; font-size: 10px;"></i>';
            }
            
            return `
                <div class="${className}" data-node="${node}">
                    ${icon}
                    <div class="node-content">
                        <div class="node-name">${nodeName}</div>
                        ${reasoning ? `<div class="node-reasoning">${escapeHtml(reasoning)}</div>` : ''}
                    </div>
                </div>
            `;
        }).join('');
        
        progressContainer.innerHTML = statusItems;
    }
    
    function resetNodeProgressStatus() {
        completedNodes.clear();
        activeNode = null;
        Object.keys(nodeDataStore).forEach(key => delete nodeDataStore[key]);
        // Remove all node progress containers
        document.querySelectorAll('.node-progress-container').forEach(el => el.remove());
    }
    
    // ====================================================================================
    // PHASE 3: Typing Indicator
    // ====================================================================================
    
    function showTypingIndicator(containerId) {
        const container = document.getElementById(containerId);
        if (!container) return null;
        
        const typingId = 'typing-' + Date.now();
        const typingDiv = document.createElement('div');
        typingDiv.id = typingId;
        typingDiv.className = 'typing-indicator';
        typingDiv.innerHTML = `
            <span>Agent is thinking</span>
            <span class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </span>
        `;
        
        const markdownBody = container.querySelector('.markdown-body');
        if (markdownBody) {
            markdownBody.insertBefore(typingDiv, markdownBody.firstChild);
        }
        
        return typingId;
    }
    
    function hideTypingIndicator(typingId) {
        const typingEl = document.getElementById(typingId);
        if (!typingEl) return;
        
        typingEl.style.animation = 'fadeOut 0.2s ease-out';
        setTimeout(() => {
            if (typingEl && typingEl.parentNode) {
                typingEl.parentNode.removeChild(typingEl);
            }
        }, 200);
    }
    
    // ====================================================================================
    // PHASE 6: Smart Auto-Scroll
    // ====================================================================================
    
    function isNearBottom() {
        const threshold = 100;
        return (historyEl.scrollHeight - historyEl.scrollTop - historyEl.clientHeight) <= threshold;
    }
    
    function smoothScrollToBottom() {
        if (!isUserScrolling || isNearBottom()) {
            requestAnimationFrame(() => {
                historyEl.scrollTo({
                    top: historyEl.scrollHeight,
                    behavior: 'smooth'
                });
            });
        }
    }
    
    // Track user scrolling
    let scrollTimeout;
    historyEl.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        
        // Check if user scrolled up
        if (!isNearBottom()) {
            isUserScrolling = true;
        } else {
            isUserScrolling = false;
        }
        
        // Reset after a delay
        scrollTimeout = setTimeout(() => {
            if (isNearBottom()) {
                isUserScrolling = false;
            }
        }, 1000);
    });

    // Initialize SocketIO connection
    function initSocketIO() {
        if (typeof io === 'undefined') {
            console.warn('SocketIO not available, falling back to HTTP');
            return false;
        }

        socket = io();
        
        socket.on('connect', () => {
            console.log('Connected to WebSocket');
            // Authenticate
            const token = templateToken || sessionStorage.getItem('mcp_token') || '';
            if (token) {
                socket.emit('authenticate', { token: token });
            }
        });

        socket.on('authenticated', (data) => {
            if (data.success) {
                console.log('WebSocket authenticated:', data.user);
                // Join session room
                socket.emit('join_session', { session_id: sessionId });
            } else {
                console.error('WebSocket authentication failed');
            }
        });

        socket.on('session_joined', (data) => {
            console.log('Joined session room:', data.session_id);
        });

        socket.on('agent:node_start', (data) => {
            console.log('Node started:', data.node);
            currentStreamingNode = data.node;
            activeNode = data.node;
            updateNodeProgressStatus();
            
        });

        socket.on('agent:llm_chunk', (data) => {
            const node = data.node;
            const chunk = data.chunk;
            
            // Update accumulated text
            if (accumulatedText.hasOwnProperty(node)) {
                accumulatedText[node] = data.accumulated;
            }
            
            // Append chunk to appropriate UI element
            if (node === 'end_response' && currentResponseId) {
                appendStreamingChunk(currentResponseId, chunk, 'response');
            } else if (node === 'end_prompt_monitor' && currentPromptMonitorId) {
                appendStreamingChunk(currentPromptMonitorId, chunk, 'prompt_monitor');
            }
        });

        socket.on('agent:node_complete', (data) => {
            console.log('Node completed:', data.node);
            if (data.node === currentStreamingNode) {
                currentStreamingNode = null;
            }
            completedNodes.add(data.node);
            if (activeNode === data.node) {
                activeNode = null;
            }
            updateNodeProgressStatus();
        });

        socket.on('agent:node_data', (data) => {
            console.log('üîçüîçüîç NEW CODE VERSION - NODE DATA RECEIVED üîçüîçüîç');
            console.log('=== NODE DATA RECEIVED ===');
            console.log('Node:', data.node);
            console.log('Session ID:', data.session_id);
            console.log('Data keys:', Object.keys(data.data || {}));
            console.log('Has node_reasoning:', !!data.data.node_reasoning);
            if (data.data.node_reasoning) {
                console.log('‚úÖ‚úÖ‚úÖ node_reasoning FOUND:', data.data.node_reasoning);
            } else {
                console.log('‚ùå‚ùå‚ùå NO node_reasoning in data');
            }
            console.log('Full data object:', JSON.stringify(data.data, null, 2));
            console.log('==========================');
            
            // Store node data for progress status display
            nodeDataStore[data.node] = data.data;
            updateNodeProgressStatus();
            
            displayNodeData(data.node, data.data);
        });

        socket.on('agent:complete', (data) => {
            console.log('=== WEBSOCKET AGENT COMPLETE ===');
            console.log('Data:', data);
            console.log('Has result?:', !!data.result);
            if (data.result && data.result.final_output) {
                console.log('final_output.response:', data.result.final_output.response);
            }
            console.log('===================================');
            console.log('Agent completed');
            const result = data.result;
            
            // Mark end node as completed
            completedNodes.add('end');
            activeNode = null;
            updateNodeProgressStatus();
            
            // Final result received - update UI with complete data
            if (currentResponseId) {
                finalizeStreamingMessage(currentResponseId, result);
            }
            
            $('#sendBtn').prop('disabled', false);
            isQueryRunning = false;
            killBtn.style.display = 'none';
        });

        socket.on('agent:waiting_for_clarification', (data) => {
            console.log('Agent waiting for clarification:', data);
            
            // Update node progress status to show waiting
            updateNodeProgressStatus();
            
            // Show clarification prompt to user
            if (currentResponseId) {
                const msgEl = document.getElementById(currentResponseId);
                if (msgEl) {
                    const markdownBody = msgEl.querySelector('.markdown-body');
                    if (markdownBody && data.clarify_prompt) {
                        // Use marked to render the clarification prompt
                        markdownBody.innerHTML = marked.parse(data.clarify_prompt);
                    }
                }
            } else {
                // Create new message with clarification
                appendMessage('agent', data.clarify_prompt || 'I need clarification on your query. Please provide more details.');
            }
            
            // Re-enable send button so user can respond
            $('#sendBtn').prop('disabled', false);
            isQueryRunning = false;
            killBtn.style.display = 'none';
        });

        socket.on('agent:cancelled', (data) => {
            console.log('Agent query cancelled:', data.message);
            
            // Hide loading states
            updateNodeProgressStatus();
            
            // Show cancellation message
            if (currentResponseId) {
                const msgEl = document.getElementById(currentResponseId);
                if (msgEl) {
                    const markdownBody = msgEl.querySelector('.markdown-body');
                    if (markdownBody) {
                        markdownBody.innerHTML = '<i class="bi bi-x-circle"></i> <em>Query cancelled by user. No entry saved to conversation history.</em>';
                    }
                }
            }
            
            $('#sendBtn').prop('disabled', false);
            isQueryRunning = false;
            killBtn.style.display = 'none';
        });

        socket.on('agent:killed', (data) => {
            console.log('Kill confirmed:', data.message);
            // The agent:cancelled event will handle the UI update
        });

        socket.on('agent:kill_error', (data) => {
            console.error('Kill error:', data.error);
            alert('Failed to cancel query: ' + data.error);
        });

        socket.on('agent:error', (data) => {
            console.error('Agent error:', data.error);
            
            // Hide loading states
            
            // Show error in node progress status
            updateNodeProgressStatus();
            
            // Show error message
            if (currentResponseId) {
                const msgEl = document.getElementById(currentResponseId);
                if (msgEl) {
                    msgEl.classList.add('error-message');
                    const markdownBody = msgEl.querySelector('.markdown-body');
                    if (markdownBody) {
                        markdownBody.innerHTML = '<i class="bi bi-exclamation-triangle"></i> Error: ' + escapeHtml(data.error);
                    }
                }
            } else {
                appendMessage('agent', 'Error: ' + data.error);
            }
            
            $('#sendBtn').prop('disabled', false);
            isQueryRunning = false;
            killBtn.style.display = 'none';
        });

        socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });

        return true;
    }

    // Initialize SocketIO on page load
    const socketAvailable = initSocketIO();

    function escapeHtml(str) {
        if (!str) return '';
        // Convert to string first (handles objects, numbers, etc)
        const text = (typeof str === 'string') ? str : String(str);
        return text.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }

    // Track node data displays to avoid duplicates (keyed by responseId + nodeName)
    const nodeDataDisplays = {};

    function displayNodeData(nodeName, nodeData) {
        if (!nodeData || Object.keys(nodeData).length === 0) {
            return;
        }

        console.log(`[NODE_DATA] Displaying data for ${nodeName}:`, nodeData);
        if (nodeData.raw_table) {
            console.log(`[NODE_DATA] Raw table: ${nodeData.raw_table.row_count || 0} rows, ${nodeData.raw_table.columns?.length || 0} columns`);
            if (nodeData.raw_table.query) {
                console.log(`[NODE_DATA] SQL Query:`, nodeData.raw_table.query);
            }
        }
        if (nodeData.plan) {
            console.log(`[NODE_DATA] SQL Plan:`, nodeData.plan.sql);
        }

        // Get or create container for this node's data (reuse if exists for same response)
        const containerKey = `${currentResponseId || 'default'}_${nodeName}`;
        let container = nodeDataDisplays[containerKey];
        
        // If container doesn't exist, try to create it
        if (!container) {
            // Try current response first - attach BEFORE the markdown-body (above response)
            if (currentResponseId) {
                const responseEl = document.getElementById(currentResponseId);
                if (responseEl) {
                    const wrapper = responseEl.closest('.mb-3');
                    if (wrapper) {
                        const messageDiv = wrapper.querySelector('.chat-message.agent');
                        if (messageDiv) {
                            // Create container and insert BEFORE the messageDiv (above the response)
                            container = document.createElement('div');
                            container.className = 'node-data-container mt-2';
                            container.setAttribute('data-node', nodeName);
                            container.setAttribute('data-container-key', containerKey);
                            wrapper.insertBefore(container, messageDiv);
                            nodeDataDisplays[containerKey] = container;
                        }
                    }
                }
            }
            
            // If still no container, try to find the last agent message
            if (!container) {
                const historyEl = document.getElementById('chatHistory');
                if (historyEl) {
                    const agentMessages = Array.from(historyEl.querySelectorAll('.chat-message.agent'));
                    if (agentMessages.length > 0) {
                        const lastAgentMessage = agentMessages[agentMessages.length - 1];
                        const wrapper = lastAgentMessage.closest('.mb-3');
                        if (wrapper) {
                            container = document.createElement('div');
                            container.className = 'node-data-container mt-2';
                            container.setAttribute('data-node', nodeName);
                            container.setAttribute('data-container-key', containerKey);
                            wrapper.insertBefore(container, lastAgentMessage);
                            nodeDataDisplays[containerKey] = container;
                        }
                    }
                }
            }
        }

        if (!container) {
            console.warn(`[NODE_DATA] Could not find container for ${nodeName}, currentResponseId: ${currentResponseId}`);
            // Still log the data even if we can't display it
            return;
        }

            // Display data based on node type
            if (nodeName === 'execute_sql' && nodeData.raw_table) {
                displayRawTable(container, nodeData.raw_table, `table_execute_${Date.now()}`);
            } else if (nodeName === 'generate_sql' && nodeData.plan) {
                displaySQLPlan(container, nodeData.plan);
            } else if (nodeName === 'synthesize' && nodeData.raw_table) {
            // Only show synthesize table if execute_sql didn't already show it (to avoid duplicates)
            const existingExecuteTable = container.parentElement?.querySelector(`[data-container-key*="_execute_sql"] .node-raw-table`);
            if (!existingExecuteTable) {
                displayRawTable(container, nodeData.raw_table, `table_synthesize_${Date.now()}`);
            }
        } else if (nodeName === 'end' && nodeData.raw_table) {
            displayRawTable(container, nodeData.raw_table, `table_end_${Date.now()}`);
        }
    }

    function displayRawTable(container, rawTable, tableId) {
        if (!rawTable || !rawTable.columns || !rawTable.rows) {
            return;
        }

        // Remove existing table if present
        const existingTable = container.querySelector('.node-raw-table');
        if (existingTable) {
            existingTable.remove();
        }

        const tableWrapper = document.createElement('div');
        tableWrapper.className = 'node-raw-table mt-2';
        
        const tableDetails = document.createElement('details');
        tableDetails.className = 'mt-2';
        tableDetails.open = true; // Open by default for real-time updates
            tableDetails.innerHTML = `<summary class="small text-info" style="cursor:pointer;"><i class="bi bi-table"></i> SQL Prompt & Results (${rawTable.row_count || 0} rows)</summary>`;
        
        const tableContent = document.createElement('div');
        tableContent.className = 'mt-2 p-2 bg-light border rounded';
        tableContent.style.maxHeight = '600px';
        tableContent.style.overflowY = 'auto';
        
        // Display SQL query if available
        if (rawTable.query) {
            const sqlDiv = document.createElement('div');
            sqlDiv.className = 'mb-3 p-3 rounded';
            sqlDiv.style.fontFamily = 'monospace';
            sqlDiv.style.fontSize = '0.9em';
            sqlDiv.style.backgroundColor = '#ffffff';
            sqlDiv.style.color = '#000000';
            sqlDiv.style.border = '1px solid #dee2e6';
            sqlDiv.innerHTML = '<strong style="color: #0d6efd;">SQL Query:</strong><br><pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word; color: #000000;">' + escapeHtml(rawTable.query) + '</pre>';
            tableContent.appendChild(sqlDiv);
        }
        
        // Add table HTML
        const tableDiv = document.createElement('div');
        tableDiv.innerHTML = formatTable(rawTable, tableId);
        tableContent.appendChild(tableDiv);
        
        tableDetails.appendChild(tableContent);
        tableWrapper.appendChild(tableDetails);
        container.appendChild(tableWrapper);
    }

    function displaySQLPlan(container, plan) {
        if (!plan || !plan.sql) {
            return;
        }

        // Remove existing plan if present
        const existingPlan = container.querySelector('.node-sql-plan');
        if (existingPlan) {
            existingPlan.remove();
        }

        const planDiv = document.createElement('div');
        planDiv.className = 'node-sql-plan mt-2 p-3 rounded';
        planDiv.style.backgroundColor = '#f8f9fa';
        planDiv.style.border = '1px solid #dee2e6';
        planDiv.innerHTML = `
            <div class="small text-muted mb-2"><i class="bi bi-code-square"></i> Generated SQL Plan - ${new Date().toLocaleTimeString()}</div>
            <div style="font-family: monospace; font-size: 0.9em; background-color: #ffffff; color: #000000; padding: 10px; border-radius: 4px; border: 1px solid #dee2e6;">
                <pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word; color: #000000;">${escapeHtml(plan.sql)}</pre>
            </div>
        `;
        container.appendChild(planDiv);
    }


    function formatTable(rawTable, tableId) {
        if (!rawTable || !rawTable.columns || !rawTable.rows) {
            return 'No table data available';
        }
        
        const maxRows = 1000; // DataTables can handle more rows
        const displayRows = rawTable.rows.slice(0, maxRows);
        
        let html = '<div class="table-container">';
        html += '<div class="table-search"><input type="text" class="form-control form-control-sm" id="search_' + tableId + '" placeholder="Search table..."></div>';
        html += '<div class="table-responsive"><table id="table_' + tableId + '" class="table table-sm table-striped table-bordered table-hover" style="width:100%">';
        
        // Header
        html += '<thead><tr>';
        rawTable.columns.forEach(col => {
            html += '<th>' + escapeHtml(col) + '</th>';
        });
        html += '</tr></thead>';
        
        // Rows
        html += '<tbody>';
        displayRows.forEach(row => {
            html += '<tr>';
            rawTable.columns.forEach(col => {
                const value = row[col] !== undefined ? row[col] : '';
                html += '<td>' + escapeHtml(String(value)) + '</td>';
            });
            html += '</tr>';
        });
        html += '</tbody>';
        
        html += '</table></div>';
        
        if (rawTable.row_count > maxRows) {
            html += '<div class="small text-muted mt-2">Showing first ' + maxRows + ' of ' + rawTable.row_count + ' rows</div>';
        } else {
            html += '<div class="small text-muted mt-2">Total: ' + rawTable.row_count + ' rows</div>';
        }
        
        html += '</div>';
        
        // Initialize DataTable after HTML is inserted
        setTimeout(function() {
            if ($.fn.DataTable && $('#table_' + tableId).length) {
                try {
                    const tableConfig = {
                        pageLength: 25,
                        lengthMenu: [[10, 25, 50, 100, -1], [10, 25, 50, 100, "All"]],
                        order: [],
                        responsive: true,
                        scrollX: true
                    };
                    
                    // Add buttons if available
                    if ($.fn.dataTable.Buttons) {
                        tableConfig.dom = 'Bfrtip';
                        tableConfig.buttons = ['copy', 'csv'];
                    }
                    
                    const table = $('#table_' + tableId).DataTable(tableConfig);
                    
                    // Add search functionality
                    $('#search_' + tableId).on('keyup', function() {
                        table.search(this.value).draw();
                    });
                } catch (e) {
                    console.error('DataTable initialization error:', e);
                }
            }
        }, 200);
        
        return html;
    }

    let messageCounter = 0;
    
    function appendMessage(role, text, finalOutput) {
        messageCounter++;
        const wrapper = document.createElement('div');
        wrapper.className = 'mb-3';
        
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message ' + role;
        
        const roleBadge = role === 'user' ? '<span class="badge bg-secondary me-2">You</span>' : '<span class="badge bg-success me-2">Agent</span>';
        
        // Render markdown for agent responses, plain text for user
        let contentHtml = '';
        if (role === 'agent' && typeof marked !== 'undefined') {
            try {
                // Render markdown
                const markdownHtml = marked.parse(text);
                contentHtml = '<div class="markdown-body">' + markdownHtml + '</div>';
            } catch (e) {
                console.error('Markdown rendering error:', e);
                contentHtml = '<div>' + escapeHtml(text) + '</div>';
            }
        } else {
            contentHtml = '<div>' + escapeHtml(text) + '</div>';
        }
        
        messageDiv.innerHTML = roleBadge + contentHtml;
        wrapper.appendChild(messageDiv);
        
        // If this is a user message, create the node progress container immediately
        if (role === 'user') {
            const progressContainer = document.createElement('div');
            progressContainer.className = 'node-progress-container';
            progressContainer.style.display = 'none'; // Hide until first node starts
            wrapper.appendChild(progressContainer);
        }
        
        // Removed: Raw Table and Prompt Monitor from appendMessage
        // These are now shown above the response via displayNodeData
        
        historyEl.appendChild(wrapper);
        historyEl.scrollTop = historyEl.scrollHeight;
    }

    // ====================================================================================
    // PHASE 4: Smart Markdown Rendering with Buffering
    // ====================================================================================
    
    let currentTypingId = null;
    
    function appendStreamingChunk(messageId, chunk, type) {
        const messageEl = document.getElementById(messageId);
        if (!messageEl) return;

        let targetEl = null;
        if (type === 'response') {
            targetEl = messageEl.querySelector('.markdown-body');
        } else if (type === 'prompt_monitor') {
            targetEl = messageEl.querySelector('.prompt-monitor-content');
        }

        if (targetEl) {
            // Show typing indicator on first chunk
            if (!currentTypingId && type === 'response') {
                currentTypingId = showTypingIndicator(messageId);
            }
            
            // Store accumulated text in a data attribute to avoid reading typing indicator text
            if (!targetEl.dataset.accumulatedText) {
                targetEl.dataset.accumulatedText = '';
            }
            targetEl.dataset.accumulatedText += chunk;
            
            // Re-render markdown (throttle to avoid too frequent updates)
            if (type === 'response' && typeof marked !== 'undefined') {
                // Initialize render counter
                if (!targetEl._renderCount) targetEl._renderCount = 0;
                targetEl._renderCount++;
                
                // Get accumulated text from data attribute (excludes typing indicator)
                const fullText = targetEl.dataset.accumulatedText || '';
                
                // Detect if we're in middle of a table or code block
                const inCodeBlock = (fullText.split('```').length - 1) % 2 === 1;
                const inTable = fullText.includes('|') && fullText.lastIndexOf('\n\n') < fullText.lastIndexOf('|');
                
                // Re-render every 3 chunks, or if chunk is large, or if NOT in special structure
                const shouldRender = !inCodeBlock && !inTable && (chunk.length > 100 || targetEl._renderCount % 3 === 0);
                
                if (shouldRender) {
                    requestAnimationFrame(() => {
                        try {
                            // Keep typing indicator, only update content after it
                            const typingIndicator = targetEl.querySelector('.typing-indicator');
                            const parsedHtml = marked.parse(fullText);
                            if (typingIndicator) {
                                targetEl.innerHTML = '';
                                targetEl.appendChild(typingIndicator);
                                const contentDiv = document.createElement('div');
                                contentDiv.innerHTML = parsedHtml;
                                targetEl.appendChild(contentDiv);
                            } else {
                                targetEl.innerHTML = parsedHtml;
                            }
                        } catch (e) {
                            // If markdown parsing fails, keep as text
                            console.warn('Markdown parse error during streaming:', e);
                        }
                    });
                }
            } else if (type === 'prompt_monitor' && typeof marked !== 'undefined') {
                if (!targetEl._renderCount) targetEl._renderCount = 0;
                targetEl._renderCount++;
                
                const fullText = targetEl.dataset.accumulatedText || '';
                
                if (chunk.length > 100 || targetEl._renderCount % 3 === 0) {
                    requestAnimationFrame(() => {
                        try {
                            targetEl.innerHTML = marked.parse(fullText);
                        } catch (e) {
                            targetEl.innerHTML = '<pre class="small text-muted">' + escapeHtml(fullText) + '</pre>';
                        }
                    });
                }
            }
            
            // Smart auto-scroll
            smoothScrollToBottom();
        }
    }

    function finalizeStreamingMessage(messageId, result) {
        const messageEl = document.getElementById(messageId);
        if (!messageEl) return;
        
        // Hide typing indicator
        if (currentTypingId) {
            hideTypingIndicator(currentTypingId);
            currentTypingId = null;
        }

        // Final markdown render - always render at the end to ensure proper formatting
        const responseEl = messageEl.querySelector('.markdown-body');
        if (responseEl && typeof marked !== 'undefined') {
            try {
                // Get the accumulated text from data attribute (excludes typing indicator text)
                let fullText = responseEl.dataset.accumulatedText || '';
                
                // FALLBACK: For knowledge questions or non-streamed responses, use final_output.response
                if (!fullText && result && result.final_output && result.final_output.response) {
                    fullText = result.final_output.response;
                    console.log('[finalizeStreamingMessage] No accumulated text, using final_output.response:', fullText.substring(0, 100));
                }
                
                // Parse and render markdown (final pass ensures everything is correct)
                requestAnimationFrame(() => {
                    try {
                        responseEl.innerHTML = marked.parse(fullText);
                    } catch (e) {
                        console.error('Final markdown render error:', e);
                        responseEl.innerHTML = '<pre>' + escapeHtml(fullText) + '</pre>';
                    }
                    // Clear the data attribute after final render
                    delete responseEl.dataset.accumulatedText;
                });
            } catch (e) {
                console.error('Final markdown render error:', e);
                // Fallback to escaped text if parsing fails
                responseEl.innerHTML = '<pre>' + escapeHtml(responseEl.textContent) + '</pre>';
            }
        }

        // Removed: Raw Table and Prompt Monitor from finalizeStreamingMessage
        // These are now shown above the response via displayNodeData
    }

    let awaitingClarification = false;
    let currentSessionId = sessionId;

    // Function to start a new chat session
    function startNewChat() {
        // Generate new session ID
        const newSessionId = 'sess-' + Math.random().toString(36).slice(2, 10);
        
        // Clear localStorage
        localStorage.removeItem('agent_session_id');
        localStorage.removeItem('agentSessionId');
        
        // Clear dropdown selections from localStorage to refresh from file system
        localStorage.removeItem('selected_data_dict');
        localStorage.removeItem('selected_agent_prompts');
        localStorage.removeItem('selected_welcome_tips');
        
        // Store new session ID
        localStorage.setItem('agent_session_id', newSessionId);
        
        // Update session variables
        sessionId = newSessionId;
        currentSessionId = newSessionId;
        
        // Reset dropdown selections to null so they'll use defaults from file system
        selectedDataDict = null;
        selectedAgentPrompts = null;
        selectedWelcomeTips = null;
        
        // Clear chat history
        historyEl.innerHTML = '';
        
        // Clear welcome message flag so it shows again
        sessionStorage.removeItem('welcome_message_shown');
        
        // Reset streaming state
        accumulatedText = {
            planner: '',
            evaluator: '',
            end_response: '',
            end_prompt_monitor: ''
        };
        currentResponseId = null;
        currentPromptMonitorId = null;
        resetNodeProgressStatus();
        awaitingClarification = false;
        
        // Rejoin socket session if connected
        if (socket && socket.connected) {
            socket.emit('join_session', { session_id: newSessionId });
            console.log('Started new chat session:', newSessionId);
        }
        
        // Reload config files to refresh dropdowns from actual file system
        loadConfigFiles();
        
        // Optionally delete old session file on server (optional cleanup)
        // This is handled automatically when a new session ID is used
        
        // Show confirmation
        const welcomeMsg = document.createElement('div');
        welcomeMsg.className = 'alert alert-info mb-2';
        welcomeMsg.innerHTML = '<i class="bi bi-info-circle"></i> <strong>New Chat Started</strong> - Previous conversation history cleared.';
        historyEl.appendChild(welcomeMsg);
        smoothScrollToBottom();
        
        // Remove welcome message after 3 seconds
        setTimeout(() => {
            if (welcomeMsg.parentNode) {
                welcomeMsg.remove();
            }
        }, 3000);
        
        // Load welcome message for new chat (after dropdowns are refreshed)
        setTimeout(() => {
            loadWelcomeMessage();
        }, 500);
    }

    function sendQuery() {
        const q = inputEl.value.trim();
        if (!q) return;
        appendMessage('user', q);
        inputEl.value = '';
        $('#sendBtn').prop('disabled', true);
        isQueryRunning = true;
        killBtn.style.display = 'inline-block';

        // Reset streaming state
        accumulatedText = {
            planner: '',
            evaluator: '',
            end_response: '',
            end_prompt_monitor: ''
        };
        currentStreamingNode = null;
        currentTypingId = null;

        // Create placeholder for agent response
        messageCounter++;
        currentResponseId = 'msg-' + messageCounter;
        currentPromptMonitorId = 'prompt-' + messageCounter;
        
        const wrapper = document.createElement('div');
        wrapper.className = 'mb-3 message-fade-in';
        const messageDiv = document.createElement('div');
        messageDiv.id = currentResponseId;
        messageDiv.className = 'chat-message agent';
        messageDiv.innerHTML = '<span class="badge bg-success me-2">Agent</span><div class="markdown-body"></div>';
        wrapper.appendChild(messageDiv);
        historyEl.appendChild(wrapper);
        
        // Clear previous node data displays for this response
        // (We'll track by responseId, so old displays won't interfere)
        // nodeDataDisplays will be keyed by responseId_nodeName, so they're naturally scoped
        
        // Reset and initialize node progress status
        resetNodeProgressStatus();
        
        // Smooth scroll to new message
        smoothScrollToBottom();

        // Use WebSocket if available, otherwise fall back to HTTP
        if (socketAvailable && socket && socket.connected) {
            // Use WebSocket streaming
            const requestData = {
                query: q,
                session_id: currentSessionId,
                token: templateToken || sessionStorage.getItem('mcp_token') || '',
                data_dict_file: selectedDataDict || null,
                agent_prompts_file: selectedAgentPrompts || null
            };

            if (awaitingClarification) {
                requestData.user_clarification = q;
                awaitingClarification = false;
                inputEl.placeholder = 'Ask a question or provide a follow-up...';
            }

            socket.emit('agent:query', requestData);
        } else {
            // Fall back to HTTP POST
            const requestArgs = {
                query: q,
                session_id: currentSessionId,
                user_id: '{{ user.user_id | default("anonymous") }}',
                data_dict_file: selectedDataDict || null,
                agent_prompts_file: selectedAgentPrompts || null
            };

            if (awaitingClarification) {
                requestArgs.user_clarification = q;
                awaitingClarification = false;
                inputEl.placeholder = 'Ask a question or provide a follow-up...';
            }

            API.post('/api/tools/execute', {
                tool: 'parquet_agent',
                arguments: requestArgs
            }).done(function(resp) {
            console.log('API Response:', resp);
            const result = (resp && resp.result) ? resp.result : resp;
            console.log('Result:', result);
            
            // Update session ID if provided
            if (result.session_id) {
                currentSessionId = result.session_id;
                localStorage.setItem('agentSessionId', currentSessionId);
            }
            
            // Check if agent needs clarification
            if (result.control === 'wait_for_user' && result.clarify_prompt) {
                // Agent is asking for clarification
                console.log('Clarification needed:', result.clarify_prompt);
                appendMessage('agent', result.clarify_prompt);
                awaitingClarification = true;
                inputEl.placeholder = 'Provide clarification...';
            } else {
                // Normal response
                const finalOut = (result && result.final_output) ? result.final_output : {};
                const answer = finalOut.response || JSON.stringify(result).slice(0, 1000);
                console.log('=== AGENT COMPLETE DEBUG ===');
                console.log('Full Result:', result);
                console.log('Final Output:', finalOut);
                console.log('Answer extracted:', answer);
                console.log('Answer length:', answer ? answer.length : 0);
                console.log('===========================');
                
                // Update the placeholder message with final result
                if (currentResponseId) {
                    // If we have a streaming placeholder, finalize it
                    finalizeStreamingMessage(currentResponseId, result);
                } else {
                    // Otherwise use regular appendMessage (which handles markdown)
                    appendMessage('agent', answer, result);
                }
                awaitingClarification = false;
                inputEl.placeholder = 'Ask a question or provide a follow-up...';
            }
        }).fail(function(xhr) {
            const err = (xhr.responseJSON && xhr.responseJSON.error) ? xhr.responseJSON.error : ('HTTP ' + xhr.status);
            
            // Hide loading states
            
            // Show error in node progress status
            updateNodeProgressStatus();
            
            // Show error message
            if (currentResponseId) {
                const msgEl = document.getElementById(currentResponseId);
                if (msgEl) {
                    msgEl.classList.add('error-message');
                    const markdownBody = msgEl.querySelector('.markdown-body');
                    if (markdownBody) {
                        markdownBody.innerHTML = '<i class="bi bi-exclamation-triangle"></i> Error: ' + escapeHtml(err);
                    }
                }
            } else {
                appendMessage('agent', 'Error: ' + err);
            }
            awaitingClarification = false;
            inputEl.placeholder = 'Ask a question or provide a follow-up...';
        }).always(function() {
            $('#sendBtn').prop('disabled', false);
            
            // Clean up state variables
            currentResponseId = null;
            currentPromptMonitorId = null;
            resetNodeProgressStatus();
            currentTypingId = null;
        });
        }
    }

    // Initialize node progress status on page load
    resetNodeProgressStatus();
    
    // ====================================================================================
    // PHASE: Welcome Message on Page Load
    // ====================================================================================
    
    function loadWelcomeMessage() {
        // Check if chat history is empty - if so, always show welcome message
        const hasMessages = historyEl && historyEl.children.length > 0;
        
        // If there are messages, check if welcome was already shown
        if (hasMessages) {
            const welcomeShown = sessionStorage.getItem('welcome_message_shown');
            if (welcomeShown === 'true') {
                console.log('[Welcome] Chat has messages and welcome already shown, skipping');
                return;
            }
        } else {
            // Chat is empty - clear the flag to ensure welcome shows
            sessionStorage.removeItem('welcome_message_shown');
            console.log('[Welcome] Chat is empty, will show welcome message');
        }
        
        console.log('[Welcome] Loading welcome message...');
        
        // Load welcome message from API with selected config file
        const fileParam = selectedWelcomeTips ? `?file=${encodeURIComponent(selectedWelcomeTips)}` : '';
        $.ajax({
            url: '/api/agent/welcome-message' + fileParam,
            method: 'GET',
            success: function(data) {
                console.log('[Welcome] Message loaded successfully:', data);
                if (data && data.sections && data.sections.length > 0) {
                    displayWelcomeMessage(data);
                    sessionStorage.setItem('welcome_message_shown', 'true');
                } else {
                    console.warn('[Welcome] Message data is empty or invalid');
                }
            },
            error: function(xhr, status, error) {
                console.error('[Welcome] Failed to load welcome message:', error, xhr);
                // Continue without welcome message
            }
        });
    }
    
    // Load config files list for each dropdown based on type
    function loadConfigFiles() {
        // Load data dictionary files (from config/ root)
        $.ajax({
            url: '/api/agent/config-files?type=data_dict',
            method: 'GET',
            success: function(data) {
                if (data && data.files) {
                    populateDropdown(dataDictSelect, data.files, selectedDataDict);
                }
            },
            error: function(xhr, status, error) {
                console.error('[Config] Failed to load data dictionary files:', error);
                dataDictSelect.innerHTML = '<option value="">Error loading files</option>';
            }
        });
        
        // Load agent prompts files (from config/agent/)
        $.ajax({
            url: '/api/agent/config-files?type=agent_prompts',
            method: 'GET',
            success: function(data) {
                if (data && data.files) {
                    populateDropdown(agentPromptsSelect, data.files, selectedAgentPrompts);
                }
            },
            error: function(xhr, status, error) {
                console.error('[Config] Failed to load agent prompts files:', error);
                agentPromptsSelect.innerHTML = '<option value="">Error loading files</option>';
            }
        });
        
        // Load welcome tips files (from config/ root)
        $.ajax({
            url: '/api/agent/config-files?type=welcome',
            method: 'GET',
            success: function(data) {
                if (data && data.files) {
                    populateDropdown(welcomeTipsSelect, data.files, selectedWelcomeTips);
                }
            },
            error: function(xhr, status, error) {
                console.error('[Config] Failed to load welcome tips files:', error);
                welcomeTipsSelect.innerHTML = '<option value="">Error loading files</option>';
            }
        });
    }
    
    function populateDropdown(selectEl, files, selectedValue) {
        selectEl.innerHTML = '';
        if (files.length === 0) {
            selectEl.innerHTML = '<option value="">No files found</option>';
        } else {
            let foundSelected = false;
            files.forEach(function(file) {
                const option = document.createElement('option');
                option.value = file.name;
                option.textContent = file.name;
                if (file.name === selectedValue) {
                    option.selected = true;
                    foundSelected = true;
                }
                selectEl.appendChild(option);
            });
            // If selectedValue doesn't match any file, select the first one
            if (!foundSelected && files.length > 0) {
                selectEl.selectedIndex = 0;
                // Update the corresponding variable based on which dropdown this is
                if (selectEl === dataDictSelect) {
                    selectedDataDict = files[0].name;
                    localStorage.setItem('selected_data_dict', selectedDataDict);
                } else if (selectEl === agentPromptsSelect) {
                    selectedAgentPrompts = files[0].name;
                    localStorage.setItem('selected_agent_prompts', selectedAgentPrompts);
                } else if (selectEl === welcomeTipsSelect) {
                    selectedWelcomeTips = files[0].name;
                    localStorage.setItem('selected_welcome_tips', selectedWelcomeTips);
                }
            }
        }
    }
    
    // Handle data dictionary selection
    dataDictSelect.addEventListener('change', function() {
        selectedDataDict = this.value;
        if (selectedDataDict) {
            localStorage.setItem('selected_data_dict', selectedDataDict);
            console.log('[Config] Data dictionary changed to:', selectedDataDict);
            // TODO: Pass to agent on next query
        }
    });
    
    // Handle agent prompts selection
    agentPromptsSelect.addEventListener('change', function() {
        selectedAgentPrompts = this.value;
        if (selectedAgentPrompts) {
            localStorage.setItem('selected_agent_prompts', selectedAgentPrompts);
            console.log('[Config] Agent prompts changed to:', selectedAgentPrompts);
            // TODO: Pass to agent on next query
        }
    });
    
    // Handle welcome tips selection
    welcomeTipsSelect.addEventListener('change', function() {
        selectedWelcomeTips = this.value;
        if (selectedWelcomeTips) {
            localStorage.setItem('selected_welcome_tips', selectedWelcomeTips);
            // Reload welcome message with new file
            sessionStorage.removeItem('welcome_message_shown');
            loadWelcomeMessage();
        }
    });
    
    // Handle data dictionary upload
    dataDictUpload.addEventListener('change', function(e) {
        handleFileUpload(e, 'data_dict', function(filename) {
            selectedDataDict = filename;
            localStorage.setItem('selected_data_dict', selectedDataDict);
            dataDictSelect.value = selectedDataDict;
            console.log('[Config] Data dictionary uploaded:', filename);
        });
    });
    
    // Handle agent prompts upload
    agentPromptsUpload.addEventListener('change', function(e) {
        handleFileUpload(e, 'agent_prompts', function(filename) {
            selectedAgentPrompts = filename;
            localStorage.setItem('selected_agent_prompts', selectedAgentPrompts);
            agentPromptsSelect.value = selectedAgentPrompts;
            console.log('[Config] Agent prompts uploaded:', filename);
        });
    });
    
    // Handle welcome tips upload
    welcomeTipsUpload.addEventListener('change', function(e) {
        handleFileUpload(e, 'welcome', function(filename) {
            selectedWelcomeTips = filename;
            localStorage.setItem('selected_welcome_tips', selectedWelcomeTips);
            welcomeTipsSelect.value = selectedWelcomeTips;
            // Reload welcome message
            sessionStorage.removeItem('welcome_message_shown');
            loadWelcomeMessage();
        });
    });
    
    // Generic file upload handler
    function handleFileUpload(e, configType, onSuccess) {
        const file = e.target.files[0];
        if (!file) return;
        
        if (!file.name.endsWith('.json')) {
            alert('Only JSON files are allowed');
            return;
        }
        
        const formData = new FormData();
        formData.append('file', file);
        formData.append('config_type', configType);
        
        $.ajax({
            url: '/api/agent/config-upload',
            method: 'POST',
            data: formData,
            processData: false,
            contentType: false,
            success: function(data) {
                if (data.success) {
                    alert('File uploaded successfully: ' + data.filename);
                    // Reload config files list
                    loadConfigFiles();
                    // Call success callback
                    if (onSuccess) onSuccess(data.filename);
                } else {
                    alert('Upload failed: ' + (data.error || 'Unknown error'));
                }
            },
            error: function(xhr, status, error) {
                const errorMsg = xhr.responseJSON && xhr.responseJSON.error ? xhr.responseJSON.error : error;
                alert('Upload failed: ' + errorMsg);
            }
        });
        
        // Reset file input
        e.target.value = '';
    }
    
    function displayWelcomeMessage(welcomeData) {
        if (!welcomeData || !welcomeData.sections || welcomeData.sections.length === 0) {
            return;
        }
        
        // Build markdown content from JSON structure
        let markdownContent = '';
        
        // Title
        if (welcomeData.title) {
            markdownContent += `# ${welcomeData.title}\n\n`;
        }
        
        // Subtitle
        if (welcomeData.subtitle) {
            markdownContent += `*${welcomeData.subtitle}*\n\n`;
        }
        
        // Process sections
        welcomeData.sections.forEach(section => {
            // Section heading
            const headingLevel = section.level || 'h2';
            const headingTag = headingLevel === 'h2' ? '##' : headingLevel === 'h3' ? '###' : '#';
            markdownContent += `${headingTag} ${section.heading}\n\n`;
            
            // Section content
            if (section.content) {
                markdownContent += `${section.content}\n\n`;
            }
            
            // Subsections
            if (section.subsections) {
                section.subsections.forEach(subsection => {
                    const subHeadingTag = subsection.level === 'h3' ? '###' : subsection.level === 'h2' ? '##' : '####';
                    markdownContent += `${subHeadingTag} ${subsection.heading}\n\n`;
                    
                    if (subsection.content) {
                        markdownContent += `${subsection.content}\n`;
                    }
                    
                    if (subsection.items) {
                        subsection.items.forEach(item => {
                            markdownContent += `- ${item}\n`;
                        });
                    }
                    
                    if (subsection.note) {
                        markdownContent += `\n> ${subsection.note}\n`;
                    }
                    
                    if (subsection.tip) {
                        markdownContent += `\nüí° **Tip**: ${subsection.tip}\n`;
                    }
                    
                    markdownContent += '\n';
                });
            }
            
            // Section items
            if (section.items) {
                section.items.forEach(item => {
                    markdownContent += `- ${item}\n`;
                });
            }
            
            // Section note
            if (section.note) {
                markdownContent += `\n> ${section.note}\n`;
            }
            
            // Section tip
            if (section.tip) {
                markdownContent += `\nüí° **Tip**: ${section.tip}\n`;
            }
            
            markdownContent += '\n';
        });
        
        // Display as agent message
        if (typeof marked !== 'undefined' && historyEl) {
            try {
                const htmlContent = marked.parse(markdownContent);
                const wrapper = document.createElement('div');
                wrapper.className = 'mb-3 message-fade-in';
                
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message agent';
                messageDiv.innerHTML = '<span class="badge bg-info me-2">Welcome</span><div class="markdown-body">' + htmlContent + '</div>';
                
                wrapper.appendChild(messageDiv);
                historyEl.insertBefore(wrapper, historyEl.firstChild);
                
                console.log('[Welcome] Message displayed successfully');
                
                // Smooth scroll to top to show welcome message
                setTimeout(() => {
                    if (historyEl) {
                        historyEl.scrollTop = 0;
                    }
                }, 100);
            } catch (e) {
                console.error('[Welcome] Error displaying message:', e);
            }
        } else {
            console.warn('[Welcome] marked.js not available or historyEl not found');
        }
    }
    
    // Load welcome message on page load - ensure jQuery and DOM are ready
    // Since this code runs in an IIFE, we need to wait for jQuery
    function initWelcomeMessage() {
        if (typeof $ !== 'undefined' && typeof historyEl !== 'undefined' && historyEl) {
            // Wait a bit more to ensure DOM is fully rendered
            setTimeout(function() {
                loadWelcomeMessage();
            }, 200);
        } else {
            // Retry after a short delay if jQuery or historyEl not ready
            setTimeout(initWelcomeMessage, 100);
        }
    }
    
    // Load existing agents
    function loadExistingAgents() {
        $.ajax({
            url: '/api/agent/data-analysis-agents',
            method: 'GET',
            success: function(data) {
                if (data && data.agents) {
                    existingAgentsSelect.innerHTML = '';
                    if (data.agents.length === 0) {
                        existingAgentsSelect.innerHTML = '<option value="">No agents saved yet</option>';
                        activateAgentBtn.disabled = true;
                    } else {
                        existingAgentsSelect.innerHTML = '<option value="">Select an agent...</option>';
                        let defaultAgentId = null;
                        data.agents.forEach(function(agent) {
                            const option = document.createElement('option');
                            option.value = agent.id;
                            option.textContent = `${agent.domain} - ${agent.name}`;
                            existingAgentsSelect.appendChild(option);
                            
                            // Check if this is the default MR agent
                            if (agent.id === 'mr_limits_analysis' || 
                                (agent.domain === 'Market Risk' && agent.name === 'Limits Analysis')) {
                                defaultAgentId = agent.id;
                            }
                        });
                        activateAgentBtn.disabled = false;
                        
                        // Check if there's an active agent in localStorage
                        const activeAgentId = localStorage.getItem('active_agent_id');
                        if (activeAgentId) {
                            // Check if this agent still exists
                            const agentExists = data.agents.some(a => a.id === activeAgentId);
                            if (agentExists) {
                                existingAgentsSelect.value = activeAgentId;
                                activateAgentBtn.disabled = false;
                                // Restore the agent configuration silently
                                activateAgentSilently(activeAgentId);
                            } else {
                                // Agent no longer exists, clear it
                                localStorage.removeItem('active_agent_id');
                                // Auto-activate default MR agent
                                if (defaultAgentId) {
                                    existingAgentsSelect.value = defaultAgentId;
                                    activateAgentSilently(defaultAgentId);
                                }
                            }
                        } else if (defaultAgentId) {
                            // No active agent, auto-activate default MR agent
                            existingAgentsSelect.value = defaultAgentId;
                            activateAgentBtn.disabled = false;
                            activateAgentSilently(defaultAgentId);
                        }
                    }
                }
            },
            error: function(xhr, status, error) {
                console.error('[Agents] Failed to load existing agents:', error);
                existingAgentsSelect.innerHTML = '<option value="">Error loading agents</option>';
            }
        });
    }
    
    // Activate agent silently (without alert) - used for default agent
    function activateAgentSilently(agentId) {
        $.ajax({
            url: '/api/agent/data-analysis-agents/' + encodeURIComponent(agentId),
            method: 'GET',
            success: function(data) {
                if (data && data.agent) {
                    const agent = data.agent;
                    
                    // Set the three dropdowns
                    if (agent.data_dict_file) {
                        selectedDataDict = agent.data_dict_file;
                        dataDictSelect.value = selectedDataDict;
                        localStorage.setItem('selected_data_dict', selectedDataDict);
                    }
                    
                    if (agent.agent_prompts_file) {
                        selectedAgentPrompts = agent.agent_prompts_file;
                        agentPromptsSelect.value = selectedAgentPrompts;
                        localStorage.setItem('selected_agent_prompts', selectedAgentPrompts);
                    }
                    
                    if (agent.welcome_tips_file) {
                        selectedWelcomeTips = agent.welcome_tips_file;
                        welcomeTipsSelect.value = selectedWelcomeTips;
                        localStorage.setItem('selected_welcome_tips', selectedWelcomeTips);
                        // Reload welcome message
                        sessionStorage.removeItem('welcome_message_shown');
                        loadWelcomeMessage();
                    }
                    
                    // Set domain and name fields
                    agentDomain.value = agent.domain || '';
                    agentName.value = agent.name || '';
                    
                    // Mark as active
                    localStorage.setItem('active_agent_id', agentId);
                    
                    console.log(`[Agents] Default agent "${agent.domain} - ${agent.name}" activated automatically`);
                }
            },
            error: function(xhr, status, error) {
                console.error('[Agents] Failed to activate default agent:', error);
            }
        });
    }
    
    // Save agent configuration
    function saveAgentConfig() {
        const domain = agentDomain.value.trim();
        const name = agentName.value.trim();
        const dataDict = selectedDataDict;
        const agentPrompts = selectedAgentPrompts;
        const welcomeTips = selectedWelcomeTips;
        
        if (!domain || !name) {
            alert('Please provide both Domain and Name');
            return;
        }
        
        if (!dataDict || !agentPrompts || !welcomeTips) {
            alert('Please select all three configuration files (Database business instructions, Agent Prompts, Welcome Tips)');
            return;
        }
        
        const agentConfig = {
            domain: domain,
            name: name,
            data_dict_file: dataDict,
            agent_prompts_file: agentPrompts,
            welcome_tips_file: welcomeTips,
            created_at: new Date().toISOString()
        };
        
        $.ajax({
            url: '/api/agent/data-analysis-agents',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify(agentConfig),
            success: function(data) {
                if (data.success) {
                    alert('Agent configuration saved successfully!');
                    agentDomain.value = '';
                    agentName.value = '';
                    loadExistingAgents(); // Reload the list
                } else {
                    alert('Failed to save agent: ' + (data.error || 'Unknown error'));
                }
            },
            error: function(xhr, status, error) {
                const errorMsg = xhr.responseJSON && xhr.responseJSON.error ? xhr.responseJSON.error : error;
                alert('Failed to save agent: ' + errorMsg);
            }
        });
    }
    
    // Activate agent configuration
    function activateAgent() {
        const agentId = existingAgentsSelect.value;
        if (!agentId) {
            alert('Please select an agent to activate');
            return;
        }
        
        $.ajax({
            url: '/api/agent/data-analysis-agents/' + encodeURIComponent(agentId),
            method: 'GET',
            success: function(data) {
                if (data && data.agent) {
                    const agent = data.agent;
                    
                    // Set the three dropdowns
                    if (agent.data_dict_file) {
                        selectedDataDict = agent.data_dict_file;
                        dataDictSelect.value = selectedDataDict;
                        localStorage.setItem('selected_data_dict', selectedDataDict);
                    }
                    
                    if (agent.agent_prompts_file) {
                        selectedAgentPrompts = agent.agent_prompts_file;
                        agentPromptsSelect.value = selectedAgentPrompts;
                        localStorage.setItem('selected_agent_prompts', selectedAgentPrompts);
                    }
                    
                    if (agent.welcome_tips_file) {
                        selectedWelcomeTips = agent.welcome_tips_file;
                        welcomeTipsSelect.value = selectedWelcomeTips;
                        localStorage.setItem('selected_welcome_tips', selectedWelcomeTips);
                        // Reload welcome message
                        sessionStorage.removeItem('welcome_message_shown');
                        loadWelcomeMessage();
                    }
                    
                    // Set domain and name fields
                    agentDomain.value = agent.domain || '';
                    agentName.value = agent.name || '';
                    
                    // Mark as active
                    localStorage.setItem('active_agent_id', existingAgentsSelect.value);
                    
                    alert(`Agent "${agent.domain} - ${agent.name}" activated successfully!`);
                } else {
                    alert('Failed to load agent configuration');
                }
            },
            error: function(xhr, status, error) {
                const errorMsg = xhr.responseJSON && xhr.responseJSON.error ? xhr.responseJSON.error : error;
                alert('Failed to activate agent: ' + errorMsg);
            }
        });
    }
    
    // Start initialization
    loadConfigFiles(); // Load config files list first
    loadExistingAgents(); // Load existing agents
    initWelcomeMessage();
    
    // Event listeners
    // Kill button handler
    function killQuery() {
        if (!isQueryRunning) return;
        
        if (socketAvailable && socket && socket.connected) {
            socket.emit('agent:kill', {
                session_id: currentSessionId,
                token: templateToken || sessionStorage.getItem('mcp_token') || ''
            });
        } else {
            alert('Cannot cancel query: WebSocket not connected');
        }
    }
    
    killBtn.addEventListener('click', killQuery);
    sendBtn.addEventListener('click', sendQuery);
    inputEl.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') sendQuery();
    });
    
    // New Chat button
    const newChatBtn = document.getElementById('newChatBtn');
    if (newChatBtn) {
        newChatBtn.addEventListener('click', function() {
            if (confirm('Start a new chat? This will clear the current conversation history.')) {
                startNewChat();
            }
        });
    }
    
    // Save Agent button
    if (saveAgentBtn) {
        saveAgentBtn.addEventListener('click', saveAgentConfig);
    }
    
    // Activate Agent button
    if (activateAgentBtn) {
        activateAgentBtn.addEventListener('click', activateAgent);
    }
    
    // Enable/disable activate button based on selection
    if (existingAgentsSelect) {
        existingAgentsSelect.addEventListener('change', function() {
            activateAgentBtn.disabled = !this.value;
        });
    }
})();
</script>
{% endblock %}
