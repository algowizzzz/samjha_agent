{% extends "base.html" %}
{% block title %}Parquet Agent Chat{% endblock %}

{% block extra_css %}
<!-- Markdown CSS for better formatting -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.2.0/github-markdown.min.css">
<style>
    /* Full screen layout - override all Bootstrap defaults */
    html {
        height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    body {
        overflow: hidden !important;
        height: 100vh !important;
        margin: 0 !important;
        padding: 0 !important;
        width: 100% !important;
        display: flex !important;
        flex-direction: column !important;
        background-color: #f8f9fa !important;
    }
    /* Hide footer completely */
    footer.footer {
        display: none !important;
    }
    /* Make main container fill viewport minus navbar */
    main.container-fluid {
        margin: 0 !important;
        padding: 0 !important;
        flex: 1 !important;
        height: auto !important;
        min-height: 0 !important;
        max-width: 100% !important;
        width: 100% !important;
        overflow: hidden !important;
    }
    /* Override Bootstrap py-4 padding class */
    main.container-fluid.py-4 {
        padding: 0 !important;
    }
    /* Override any container constraints */
    .container, .container-fluid {
        max-width: 100% !important;
        width: 100% !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
        padding-top: 0 !important;
        padding-bottom: 0 !important;
    }
    /* Remove all margins and padding from content wrapper */
    main > div:first-child {
        margin: 0 !important;
        padding: 0 !important;
        width: 100% !important;
        height: 100% !important;
    }
    /* Remove card margins and ensure full width */
    .card {
        margin: 0 !important;
        margin-bottom: 0 !important;
        width: 100% !important;
        border-radius: 0 !important;
    }
    /* Remove shadow for edge-to-edge */
    .card.shadow-sm {
        box-shadow: none !important;
    }
    
    .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 100%;
        margin: 0;
        padding: 15px;
        font-size: 14px;
        background-color: white !important;
        color: #333 !important;
    }
    .markdown-body * {
        color: #333 !important;
    }
    .markdown-body pre {
        background-color: #f6f8fa;
        border-radius: 6px;
        padding: 16px;
        overflow: auto;
        color: #333 !important;
    }
    .markdown-body code {
        background-color: rgba(175, 184, 193, 0.2);
        padding: 2px 4px;
        border-radius: 3px;
        font-size: 85%;
        color: #333 !important;
    }
    .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 {
        color: #333 !important;
    }
    .chat-message {
        padding: 12px 16px;
        border-radius: 8px;
        margin-bottom: 12px;
        max-width: 85%;
    }
    .chat-message.user {
        background-color: #e9ecef;
        margin-left: auto;
        text-align: right;
    }
    .chat-message.agent {
        background-color: white;
        border: 1px solid #dee2e6;
        margin-right: auto;
        color: #333;
    }
    .table-container {
        position: relative;
    }
    .table-search {
        margin-bottom: 10px;
    }
    .prompt-monitor-content {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.4;
        font-size: 13px;
    }
    /* Make headers small and compact - no large headers in prompt monitor */
    .prompt-monitor-content h1, .prompt-monitor-content h2, .prompt-monitor-content h3 {
        margin-top: 8px;
        margin-bottom: 4px;
        font-weight: 600;
        font-size: 14px; /* Same size as body text */
    }
    .prompt-monitor-content h1 {
        font-size: 14px; /* h1 same as body */
    }
    .prompt-monitor-content h2 {
        font-size: 13px; /* h2 slightly smaller */
    }
    .prompt-monitor-content ul, .prompt-monitor-content ol {
        margin-top: 4px;
        margin-bottom: 4px;
        padding-left: 20px;
    }
    .prompt-monitor-content li {
        margin-bottom: 3px;
    }
    .prompt-monitor-content p {
        margin-top: 4px;
        margin-bottom: 4px;
    }
    .prompt-monitor-content code {
        background-color: #f4f4f4;
        padding: 2px 6px;
        border-radius: 3px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
    }
    .prompt-monitor-content strong {
        font-weight: 600;
    }
    
    /* Loading states and animations */
    .loading-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        color: #6c757d;
        font-size: 14px;
        animation: fadeIn 0.2s ease-in;
    }
    
    .typing-indicator {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        color: #6c757d;
        font-size: 13px;
        font-style: italic;
    }
    
    .typing-dots {
        display: inline-flex;
        gap: 3px;
    }
    
    .typing-dots span {
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background-color: #6c757d;
        animation: typingPulse 1.4s infinite;
    }
    
    .typing-dots span:nth-child(2) {
        animation-delay: 0.2s;
    }
    
    .typing-dots span:nth-child(3) {
        animation-delay: 0.4s;
    }
    
    /* Node Progress Status */
    .node-progress-container {
        font-size: 12px;
        color: #6c757d;
        padding: 8px 12px;
        margin-top: 8px;
        margin-bottom: 8px;
        background-color: #f8f9fa;
        border-left: 3px solid #0d6efd;
        border-radius: 4px;
    }
    
    .node-progress-item {
        display: flex;
        align-items: flex-start;
        padding: 4px 0;
        margin: 2px 0;
    }
    
    .node-progress-item .node-icon {
        margin-right: 8px;
        margin-top: 2px;
        flex-shrink: 0;
    }
    
    .node-progress-item .node-content {
        flex: 1;
    }
    
    .node-progress-item .node-name {
        font-weight: 500;
        color: #495057;
        margin-bottom: 2px;
    }
    
    .node-progress-item .node-reasoning {
        font-size: 11px;
        color: #6c757d;
        font-style: italic;
    }
    
    .node-progress-item.active .node-name {
        color: #0d6efd;
    }
    
    .node-progress-item.completed .node-name {
        color: #198754;
    }
    
    .node-progress-item.error .node-name {
        color: #dc3545;
    }
    
    /* Animations */
    @keyframes fadeIn {
        from {
            opacity: 0;
        }
        to {
            opacity: 1;
        }
    }
    
    @keyframes fadeOut {
        from {
            opacity: 1;
        }
        to {
            opacity: 0;
        }
    }
    
    @keyframes slideInDown {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    @keyframes typingPulse {
        0%, 60%, 100% {
            opacity: 0.3;
            transform: scale(0.8);
        }
        30% {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    .message-fade-in {
        animation: fadeIn 0.3s ease-in;
    }
    
    .content-smooth {
        transition: all 0.2s ease;
    }
    
    /* Error state styling */
    .error-message {
        background-color: #f8d7da;
        border-color: #f5c2c7;
        color: #842029;
    }
    
    /* Mobile responsive status bar */
    @media (max-width: 768px) {
        .status-bar {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }
        
        .status-step:not(:last-child)::after {
            display: none;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="p-0 m-0" style="height: 100%; width: 100%; display: flex; flex-direction: column; margin: 0 !important; padding: 0 !important;">
    <div class="card shadow-sm h-100 d-flex flex-column m-0" style="border-radius: 0; border: none; height: 100%; margin: 0 !important; width: 100%;">
        <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center" style="flex-shrink: 0;">
            <h5 class="mb-0"><i class="bi bi-chat-text"></i> Parquet Agent</h5>
            <div class="d-flex align-items-center gap-2">
                <button id="newChatBtn" class="btn btn-sm btn-light" title="Start a new chat session">
                    <i class="bi bi-plus-circle"></i> New Chat
                </button>
            <span class="badge bg-light text-dark">DuckDB</span>
            </div>
        </div>
        <div class="card-body d-flex flex-column p-3" style="flex: 1; overflow: hidden; min-height: 0;">
            <div id="chatHistory" class="mb-3 flex-grow-1" style="overflow-y: auto; border: 1px solid #eee; padding: 12px; border-radius: 6px; background: #fafafa; min-height: 0;">
                <!-- Messages will be appended here -->
            </div>
            <div class="input-group" style="flex-shrink: 0;">
                <input id="chatInput" type="text" class="form-control" placeholder="Ask a question or follow up..." />
                <button id="sendBtn" class="btn btn-primary">
                    <i class="bi bi-send"></i> Send
                </button>
            </div>
            <div class="form-text mt-2" style="flex-shrink: 0;">Responses include an Answer, SQL Prompt & Results, and Prompt Monitor summary.</div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Cache buster: Version 6 - Removed orphaned containers, fixed attachment -->
<script>
    (function() {
        const VERSION = 6;
        const BUILD_TIME = Date.now();
        console.log('%cðŸš€ðŸš€ðŸš€ AGENT CHAT HTML LOADED ðŸš€ðŸš€ðŸš€', 'font-size: 16px; font-weight: bold; color: #0d6efd;');
        console.log('%cVERSION ' + VERSION + ' (Clean Container Attachment)', 'font-size: 14px; font-weight: bold; color: #198754;');
        console.log('Timestamp:', new Date().toISOString());
        console.log('Build:', BUILD_TIME);
        console.log('If you see VERSION 3, your browser is caching! Do a hard refresh: Cmd+Shift+R (Mac) or Ctrl+Shift+R (Windows)');
        
        // Store version in window for debugging
        window.AGENT_CHAT_VERSION = VERSION;
        window.AGENT_CHAT_BUILD = BUILD_TIME;
    })();
</script>
<!-- Markdown Parser -->
<script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
<script>
    // Configure marked.js for GitHub Flavored Markdown (tables, etc.)
    if (typeof marked !== 'undefined') {
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: true,
            mangle: false
        });
    }
</script>
<!-- DataTables for interactive tables -->
<link rel="stylesheet" href="https://cdn.datatables.net/1.13.7/css/jquery.dataTables.min.css">
<link rel="stylesheet" href="https://cdn.datatables.net/buttons/2.4.2/css/buttons.dataTables.min.css">
<script src="https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/buttons/2.4.2/js/dataTables.buttons.min.js"></script>
<script src="https://cdn.datatables.net/buttons/2.4.2/js/buttons.html5.min.js"></script>
<script>
    // Agent Chat v5.2 - Fixed: typing indicator text bleeding into response - 2025-11-09 20:20
(function() {
    'use strict';
    // Ensure API token is available for /api/tools/execute
    const templateToken = "{{ session.token or '' }}";
    if (templateToken) {
        try {
            sessionStorage.setItem('mcp_token', templateToken);
            document.cookie = 'mcp_token=' + templateToken + '; path=/';
        } catch (e) {}
    }

    let sessionId = localStorage.getItem('agent_session_id') || '';
    if (!sessionId) {
        sessionId = 'sess-' + Math.random().toString(36).slice(2, 10);
        localStorage.setItem('agent_session_id', sessionId);
    }

    const historyEl = document.getElementById('chatHistory');
    const inputEl = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');

    // SocketIO connection for streaming
    let socket = null;
    let currentStreamingNode = null;
    let currentResponseId = null;
    let currentPromptMonitorId = null;
    let isUserScrolling = false;
    let accumulatedText = {
        planner: '',
        evaluator: '',
        end_response: '',
        end_prompt_monitor: ''
    };
    
    // ====================================================================================
    // PHASE 1: Node Progress Status (Bottom Status Bar)
    // ====================================================================================
    
    const completedNodes = new Set();
    let activeNode = null;
    const nodeDataStore = {}; // Store data and reasoning for each node
    
    function formatNodeName(nodeName) {
        // Convert node names to user-friendly format
        const nodeNames = {
            'invoke': 'Starting',
            'check_followup': 'Checking context',
            'check_data_sufficiency': 'Assessing data needs',
            'check_structure': 'Understanding request',
            'check_ambiguity': 'Reviewing clarity',
            'clarify': 'Asking for clarification',
            'process_clarification': 'Processing response',
            'generate_sql': 'Building query',
            'execute_sql': 'Running query',
            'retry_sql': 'Retrying query',
            'synthesize': 'Preparing answer',
            'end': 'Complete'
        };
        return nodeNames[nodeName] || nodeName;
    }
    
    function getNodeReasoning(node, nodeData) {
        // Get reasoning message, replacing "query" with "prompt"
        if (nodeData && nodeData.node_reasoning) {
            return nodeData.node_reasoning.replace(/query/gi, 'prompt').replace(/Query/gi, 'Prompt');
        }
        
        // Fallback: generate a simple description based on node data
        if (!nodeData) return '';
        
        const parts = [];
        if (node === 'invoke') {
            if (nodeData.has_table_schema) parts.push('Schema loaded');
            if (nodeData.has_conversation_history) parts.push('History loaded');
        } else if (node === 'check_followup') {
            parts.push(nodeData.is_followup ? 'Prompt detected as follow-up prompt' : 'Prompt detected as new prompt');
        } else if (node === 'check_data_sufficiency') {
            parts.push(nodeData.more_data_needed ? 'More data needed' : 'Filter only');
        } else if (node === 'check_structure') {
            parts.push(nodeData.is_structured ? 'Prompt classified as structured' : 'Prompt classified as knowledge');
        } else if (node === 'check_ambiguity') {
            if (nodeData.is_ambiguous) {
                const qCount = (nodeData.clarification_questions || []).length;
                parts.push(`Needs clarification (${qCount} questions)`);
            } else {
                parts.push('Prompt is clear');
            }
        } else if (node === 'generate_sql') {
            if (nodeData.plan_quality) parts.push(`Quality: ${nodeData.plan_quality}`);
        } else if (node === 'execute_sql' || node === 'synthesize') {
            const rowCount = nodeData.raw_table?.row_count || 0;
            if (rowCount > 0) parts.push(`${rowCount} rows returned`);
        } else if (node === 'end') {
            const rowCount = nodeData.raw_table?.row_count || 0;
            if (rowCount > 0) parts.push(`Completed with ${rowCount} rows`);
        }
        
        return parts.join(', ');
    }
    
    function updateNodeProgressStatus() {
        // First, remove any progress containers that are NOT inside user message wrappers
        // This ensures old containers at the bottom are removed
        const historyEl = document.getElementById('chatHistory');
        if (historyEl) {
            const allProgressContainers = historyEl.querySelectorAll('.node-progress-container');
            allProgressContainers.forEach(container => {
                const wrapper = container.closest('.mb-3');
                const userMessage = wrapper?.querySelector('.chat-message.user');
                if (!userMessage) {
                    console.log('[updateNodeProgressStatus] Removing orphaned progress container');
                    container.remove();
                }
            });
        }
        
        // Find the last user message to attach the status to
        if (!historyEl) {
            console.warn('[updateNodeProgressStatus] chatHistory not found');
            return;
        }
        
        // Find the last user message wrapper
        const userMessages = Array.from(historyEl.querySelectorAll('.chat-message.user'));
        if (userMessages.length === 0) {
            console.warn('[updateNodeProgressStatus] No user messages found');
            return;
        }
        
        const lastUserMessage = userMessages[userMessages.length - 1];
        const wrapper = lastUserMessage.closest('.mb-3');
        if (!wrapper) {
            console.warn('[updateNodeProgressStatus] Could not find wrapper for user message');
            return;
        }
        
        // Find or create the node progress container
        let progressContainer = wrapper.querySelector('.node-progress-container');
        if (!progressContainer) {
            console.log('[updateNodeProgressStatus] Creating new progress container after user message');
            progressContainer = document.createElement('div');
            progressContainer.className = 'node-progress-container';
            wrapper.appendChild(progressContainer);
        }
        
        // Make sure it's visible
        progressContainer.style.display = 'block';
        
        // All possible nodes in order
        const allNodes = ['invoke', 'check_followup', 'check_data_sufficiency', 'check_structure', 
                         'check_ambiguity', 'generate_sql', 'execute_sql', 'synthesize', 'end'];
        
        // Only show nodes that have been started (completed or active)
        const visibleNodes = allNodes.filter(node => completedNodes.has(node) || activeNode === node);
        
        if (visibleNodes.length === 0 && !activeNode) {
            progressContainer.innerHTML = '<span class="text-muted">Waiting...</span>';
            return;
        }
        
        const statusItems = visibleNodes.map(node => {
            const nodeData = nodeDataStore[node] || {};
            const nodeName = formatNodeName(node);
            const reasoning = getNodeReasoning(node, nodeData);
            let className = 'node-progress-item';
            let icon = '';
            
            if (completedNodes.has(node)) {
                className += ' completed';
                icon = '<i class="bi bi-check-circle-fill node-icon" style="color: #198754; font-size: 12px;"></i>';
            } else if (activeNode === node) {
                className += ' active';
                icon = '<i class="bi bi-arrow-repeat spinner-border spinner-border-sm node-icon" style="width: 12px; height: 12px; color: #0d6efd;"></i>';
            } else {
                icon = '<i class="bi bi-circle node-icon" style="color: #dee2e6; font-size: 10px;"></i>';
            }
            
            return `
                <div class="${className}" data-node="${node}">
                    ${icon}
                    <div class="node-content">
                        <div class="node-name">${nodeName}</div>
                        ${reasoning ? `<div class="node-reasoning">${escapeHtml(reasoning)}</div>` : ''}
                    </div>
                </div>
            `;
        }).join('');
        
        progressContainer.innerHTML = statusItems;
    }
    
    function resetNodeProgressStatus() {
        completedNodes.clear();
        activeNode = null;
        Object.keys(nodeDataStore).forEach(key => delete nodeDataStore[key]);
        // Remove all node progress containers
        document.querySelectorAll('.node-progress-container').forEach(el => el.remove());
    }
    
    // ====================================================================================
    // PHASE 3: Typing Indicator
    // ====================================================================================
    
    function showTypingIndicator(containerId) {
        const container = document.getElementById(containerId);
        if (!container) return null;
        
        const typingId = 'typing-' + Date.now();
        const typingDiv = document.createElement('div');
        typingDiv.id = typingId;
        typingDiv.className = 'typing-indicator';
        typingDiv.innerHTML = `
            <span>Agent is thinking</span>
            <span class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </span>
        `;
        
        const markdownBody = container.querySelector('.markdown-body');
        if (markdownBody) {
            markdownBody.insertBefore(typingDiv, markdownBody.firstChild);
        }
        
        return typingId;
    }
    
    function hideTypingIndicator(typingId) {
        const typingEl = document.getElementById(typingId);
        if (!typingEl) return;
        
        typingEl.style.animation = 'fadeOut 0.2s ease-out';
        setTimeout(() => {
            if (typingEl && typingEl.parentNode) {
                typingEl.parentNode.removeChild(typingEl);
            }
        }, 200);
    }
    
    // ====================================================================================
    // PHASE 6: Smart Auto-Scroll
    // ====================================================================================
    
    function isNearBottom() {
        const threshold = 100;
        return (historyEl.scrollHeight - historyEl.scrollTop - historyEl.clientHeight) <= threshold;
    }
    
    function smoothScrollToBottom() {
        if (!isUserScrolling || isNearBottom()) {
            requestAnimationFrame(() => {
                historyEl.scrollTo({
                    top: historyEl.scrollHeight,
                    behavior: 'smooth'
                });
            });
        }
    }
    
    // Track user scrolling
    let scrollTimeout;
    historyEl.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        
        // Check if user scrolled up
        if (!isNearBottom()) {
            isUserScrolling = true;
        } else {
            isUserScrolling = false;
        }
        
        // Reset after a delay
        scrollTimeout = setTimeout(() => {
            if (isNearBottom()) {
                isUserScrolling = false;
            }
        }, 1000);
    });

    // Initialize SocketIO connection
    function initSocketIO() {
        if (typeof io === 'undefined') {
            console.warn('SocketIO not available, falling back to HTTP');
            return false;
        }

        socket = io();
        
        socket.on('connect', () => {
            console.log('Connected to WebSocket');
            // Authenticate
            const token = templateToken || sessionStorage.getItem('mcp_token') || '';
            if (token) {
                socket.emit('authenticate', { token: token });
            }
        });

        socket.on('authenticated', (data) => {
            if (data.success) {
                console.log('WebSocket authenticated:', data.user);
                // Join session room
                socket.emit('join_session', { session_id: sessionId });
            } else {
                console.error('WebSocket authentication failed');
            }
        });

        socket.on('session_joined', (data) => {
            console.log('Joined session room:', data.session_id);
        });

        socket.on('agent:node_start', (data) => {
            console.log('Node started:', data.node);
            currentStreamingNode = data.node;
            activeNode = data.node;
            updateNodeProgressStatus();
            
        });

        socket.on('agent:llm_chunk', (data) => {
            const node = data.node;
            const chunk = data.chunk;
            
            // Update accumulated text
            if (accumulatedText.hasOwnProperty(node)) {
                accumulatedText[node] = data.accumulated;
            }
            
            // Append chunk to appropriate UI element
            if (node === 'end_response' && currentResponseId) {
                appendStreamingChunk(currentResponseId, chunk, 'response');
            } else if (node === 'end_prompt_monitor' && currentPromptMonitorId) {
                appendStreamingChunk(currentPromptMonitorId, chunk, 'prompt_monitor');
            }
        });

        socket.on('agent:node_complete', (data) => {
            console.log('Node completed:', data.node);
            if (data.node === currentStreamingNode) {
                currentStreamingNode = null;
            }
            completedNodes.add(data.node);
            if (activeNode === data.node) {
                activeNode = null;
            }
            updateNodeProgressStatus();
        });

        socket.on('agent:node_data', (data) => {
            console.log('ðŸ”ðŸ”ðŸ” NEW CODE VERSION - NODE DATA RECEIVED ðŸ”ðŸ”ðŸ”');
            console.log('=== NODE DATA RECEIVED ===');
            console.log('Node:', data.node);
            console.log('Session ID:', data.session_id);
            console.log('Data keys:', Object.keys(data.data || {}));
            console.log('Has node_reasoning:', !!data.data.node_reasoning);
            if (data.data.node_reasoning) {
                console.log('âœ…âœ…âœ… node_reasoning FOUND:', data.data.node_reasoning);
            } else {
                console.log('âŒâŒâŒ NO node_reasoning in data');
            }
            console.log('Full data object:', JSON.stringify(data.data, null, 2));
            console.log('==========================');
            
            // Store node data for progress status display
            nodeDataStore[data.node] = data.data;
            updateNodeProgressStatus();
            
            displayNodeData(data.node, data.data);
        });

        socket.on('agent:complete', (data) => {
            console.log('=== WEBSOCKET AGENT COMPLETE ===');
            console.log('Data:', data);
            console.log('Has result?:', !!data.result);
            if (data.result && data.result.final_output) {
                console.log('final_output.response:', data.result.final_output.response);
            }
            console.log('===================================');
            console.log('Agent completed');
            const result = data.result;
            
            // Mark end node as completed
            completedNodes.add('end');
            activeNode = null;
            updateNodeProgressStatus();
            
            // Final result received - update UI with complete data
            if (currentResponseId) {
                finalizeStreamingMessage(currentResponseId, result);
            }
            
            $('#sendBtn').prop('disabled', false);
        });

        socket.on('agent:waiting_for_clarification', (data) => {
            console.log('Agent waiting for clarification:', data);
            
            // Update node progress status to show waiting
            updateNodeProgressStatus();
            
            // Show clarification prompt to user
            if (currentResponseId) {
                const msgEl = document.getElementById(currentResponseId);
                if (msgEl) {
                    const markdownBody = msgEl.querySelector('.markdown-body');
                    if (markdownBody && data.clarify_prompt) {
                        // Use marked to render the clarification prompt
                        markdownBody.innerHTML = marked.parse(data.clarify_prompt);
                    }
                }
            } else {
                // Create new message with clarification
                appendMessage('agent', data.clarify_prompt || 'I need clarification on your query. Please provide more details.');
            }
            
            // Re-enable send button so user can respond
            $('#sendBtn').prop('disabled', false);
        });

        socket.on('agent:error', (data) => {
            console.error('Agent error:', data.error);
            
            // Hide loading states
            
            // Show error in node progress status
            updateNodeProgressStatus();
            
            // Show error message
            if (currentResponseId) {
                const msgEl = document.getElementById(currentResponseId);
                if (msgEl) {
                    msgEl.classList.add('error-message');
                    const markdownBody = msgEl.querySelector('.markdown-body');
                    if (markdownBody) {
                        markdownBody.innerHTML = '<i class="bi bi-exclamation-triangle"></i> Error: ' + escapeHtml(data.error);
                    }
                }
            } else {
                appendMessage('agent', 'Error: ' + data.error);
            }
            
            $('#sendBtn').prop('disabled', false);
        });

        socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });

        return true;
    }

    // Initialize SocketIO on page load
    const socketAvailable = initSocketIO();

    function escapeHtml(str) {
        if (!str) return '';
        // Convert to string first (handles objects, numbers, etc)
        const text = (typeof str === 'string') ? str : String(str);
        return text.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }

    // Track node data displays to avoid duplicates (keyed by responseId + nodeName)
    const nodeDataDisplays = {};

    function displayNodeData(nodeName, nodeData) {
        if (!nodeData || Object.keys(nodeData).length === 0) {
            return;
        }

        console.log(`[NODE_DATA] Displaying data for ${nodeName}:`, nodeData);
        if (nodeData.raw_table) {
            console.log(`[NODE_DATA] Raw table: ${nodeData.raw_table.row_count || 0} rows, ${nodeData.raw_table.columns?.length || 0} columns`);
            if (nodeData.raw_table.query) {
                console.log(`[NODE_DATA] SQL Query:`, nodeData.raw_table.query);
            }
        }
        if (nodeData.plan) {
            console.log(`[NODE_DATA] SQL Plan:`, nodeData.plan.sql);
        }

        // Get or create container for this node's data (reuse if exists for same response)
        const containerKey = `${currentResponseId || 'default'}_${nodeName}`;
        let container = nodeDataDisplays[containerKey];
        
        // If container doesn't exist, try to create it
        if (!container) {
            // Try current response first - attach BEFORE the markdown-body (above response)
            if (currentResponseId) {
                const responseEl = document.getElementById(currentResponseId);
                if (responseEl) {
                    const wrapper = responseEl.closest('.mb-3');
                    if (wrapper) {
                        const messageDiv = wrapper.querySelector('.chat-message.agent');
                        if (messageDiv) {
                            // Create container and insert BEFORE the messageDiv (above the response)
                            container = document.createElement('div');
                            container.className = 'node-data-container mt-2';
                            container.setAttribute('data-node', nodeName);
                            container.setAttribute('data-container-key', containerKey);
                            wrapper.insertBefore(container, messageDiv);
                            nodeDataDisplays[containerKey] = container;
                        }
                    }
                }
            }
            
            // If still no container, try to find the last agent message
            if (!container) {
                const historyEl = document.getElementById('chatHistory');
                if (historyEl) {
                    const agentMessages = Array.from(historyEl.querySelectorAll('.chat-message.agent'));
                    if (agentMessages.length > 0) {
                        const lastAgentMessage = agentMessages[agentMessages.length - 1];
                        const wrapper = lastAgentMessage.closest('.mb-3');
                        if (wrapper) {
                            container = document.createElement('div');
                            container.className = 'node-data-container mt-2';
                            container.setAttribute('data-node', nodeName);
                            container.setAttribute('data-container-key', containerKey);
                            wrapper.insertBefore(container, lastAgentMessage);
                            nodeDataDisplays[containerKey] = container;
                        }
                    }
                }
            }
        }

        if (!container) {
            console.warn(`[NODE_DATA] Could not find container for ${nodeName}, currentResponseId: ${currentResponseId}`);
            // Still log the data even if we can't display it
            return;
        }

            // Display data based on node type
            if (nodeName === 'execute_sql' && nodeData.raw_table) {
                displayRawTable(container, nodeData.raw_table, `table_execute_${Date.now()}`);
            } else if (nodeName === 'generate_sql' && nodeData.plan) {
                displaySQLPlan(container, nodeData.plan);
            } else if (nodeName === 'synthesize' && nodeData.raw_table) {
            // Only show synthesize table if execute_sql didn't already show it (to avoid duplicates)
            const existingExecuteTable = container.parentElement?.querySelector(`[data-container-key*="_execute_sql"] .node-raw-table`);
            if (!existingExecuteTable) {
                displayRawTable(container, nodeData.raw_table, `table_synthesize_${Date.now()}`);
            }
        } else if (nodeName === 'end' && nodeData.raw_table) {
            displayRawTable(container, nodeData.raw_table, `table_end_${Date.now()}`);
        }
    }

    function displayRawTable(container, rawTable, tableId) {
        if (!rawTable || !rawTable.columns || !rawTable.rows) {
            return;
        }

        // Remove existing table if present
        const existingTable = container.querySelector('.node-raw-table');
        if (existingTable) {
            existingTable.remove();
        }

        const tableWrapper = document.createElement('div');
        tableWrapper.className = 'node-raw-table mt-2';
        
        const tableDetails = document.createElement('details');
        tableDetails.className = 'mt-2';
        tableDetails.open = true; // Open by default for real-time updates
            tableDetails.innerHTML = `<summary class="small text-info" style="cursor:pointer;"><i class="bi bi-table"></i> SQL Prompt & Results (${rawTable.row_count || 0} rows)</summary>`;
        
        const tableContent = document.createElement('div');
        tableContent.className = 'mt-2 p-2 bg-light border rounded';
        tableContent.style.maxHeight = '600px';
        tableContent.style.overflowY = 'auto';
        
        // Display SQL query if available
        if (rawTable.query) {
            const sqlDiv = document.createElement('div');
            sqlDiv.className = 'mb-3 p-3 rounded';
            sqlDiv.style.fontFamily = 'monospace';
            sqlDiv.style.fontSize = '0.9em';
            sqlDiv.style.backgroundColor = '#ffffff';
            sqlDiv.style.color = '#000000';
            sqlDiv.style.border = '1px solid #dee2e6';
            sqlDiv.innerHTML = '<strong style="color: #0d6efd;">SQL Query:</strong><br><pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word; color: #000000;">' + escapeHtml(rawTable.query) + '</pre>';
            tableContent.appendChild(sqlDiv);
        }
        
        // Add table HTML
        const tableDiv = document.createElement('div');
        tableDiv.innerHTML = formatTable(rawTable, tableId);
        tableContent.appendChild(tableDiv);
        
        tableDetails.appendChild(tableContent);
        tableWrapper.appendChild(tableDetails);
        container.appendChild(tableWrapper);
    }

    function displaySQLPlan(container, plan) {
        if (!plan || !plan.sql) {
            return;
        }

        // Remove existing plan if present
        const existingPlan = container.querySelector('.node-sql-plan');
        if (existingPlan) {
            existingPlan.remove();
        }

        const planDiv = document.createElement('div');
        planDiv.className = 'node-sql-plan mt-2 p-3 rounded';
        planDiv.style.backgroundColor = '#f8f9fa';
        planDiv.style.border = '1px solid #dee2e6';
        planDiv.innerHTML = `
            <div class="small text-muted mb-2"><i class="bi bi-code-square"></i> Generated SQL Plan - ${new Date().toLocaleTimeString()}</div>
            <div style="font-family: monospace; font-size: 0.9em; background-color: #ffffff; color: #000000; padding: 10px; border-radius: 4px; border: 1px solid #dee2e6;">
                <pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word; color: #000000;">${escapeHtml(plan.sql)}</pre>
            </div>
        `;
        container.appendChild(planDiv);
    }


    function formatTable(rawTable, tableId) {
        if (!rawTable || !rawTable.columns || !rawTable.rows) {
            return 'No table data available';
        }
        
        const maxRows = 1000; // DataTables can handle more rows
        const displayRows = rawTable.rows.slice(0, maxRows);
        
        let html = '<div class="table-container">';
        html += '<div class="table-search"><input type="text" class="form-control form-control-sm" id="search_' + tableId + '" placeholder="Search table..."></div>';
        html += '<div class="table-responsive"><table id="table_' + tableId + '" class="table table-sm table-striped table-bordered table-hover" style="width:100%">';
        
        // Header
        html += '<thead><tr>';
        rawTable.columns.forEach(col => {
            html += '<th>' + escapeHtml(col) + '</th>';
        });
        html += '</tr></thead>';
        
        // Rows
        html += '<tbody>';
        displayRows.forEach(row => {
            html += '<tr>';
            rawTable.columns.forEach(col => {
                const value = row[col] !== undefined ? row[col] : '';
                html += '<td>' + escapeHtml(String(value)) + '</td>';
            });
            html += '</tr>';
        });
        html += '</tbody>';
        
        html += '</table></div>';
        
        if (rawTable.row_count > maxRows) {
            html += '<div class="small text-muted mt-2">Showing first ' + maxRows + ' of ' + rawTable.row_count + ' rows</div>';
        } else {
            html += '<div class="small text-muted mt-2">Total: ' + rawTable.row_count + ' rows</div>';
        }
        
        html += '</div>';
        
        // Initialize DataTable after HTML is inserted
        setTimeout(function() {
            if ($.fn.DataTable && $('#table_' + tableId).length) {
                try {
                    const tableConfig = {
                        pageLength: 25,
                        lengthMenu: [[10, 25, 50, 100, -1], [10, 25, 50, 100, "All"]],
                        order: [],
                        responsive: true,
                        scrollX: true
                    };
                    
                    // Add buttons if available
                    if ($.fn.dataTable.Buttons) {
                        tableConfig.dom = 'Bfrtip';
                        tableConfig.buttons = ['copy', 'csv'];
                    }
                    
                    const table = $('#table_' + tableId).DataTable(tableConfig);
                    
                    // Add search functionality
                    $('#search_' + tableId).on('keyup', function() {
                        table.search(this.value).draw();
                    });
                } catch (e) {
                    console.error('DataTable initialization error:', e);
                }
            }
        }, 200);
        
        return html;
    }

    let messageCounter = 0;
    
    function appendMessage(role, text, finalOutput) {
        messageCounter++;
        const wrapper = document.createElement('div');
        wrapper.className = 'mb-3';
        
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message ' + role;
        
        const roleBadge = role === 'user' ? '<span class="badge bg-secondary me-2">You</span>' : '<span class="badge bg-success me-2">Agent</span>';
        
        // Render markdown for agent responses, plain text for user
        let contentHtml = '';
        if (role === 'agent' && typeof marked !== 'undefined') {
            try {
                // Render markdown
                const markdownHtml = marked.parse(text);
                contentHtml = '<div class="markdown-body">' + markdownHtml + '</div>';
            } catch (e) {
                console.error('Markdown rendering error:', e);
                contentHtml = '<div>' + escapeHtml(text) + '</div>';
            }
        } else {
            contentHtml = '<div>' + escapeHtml(text) + '</div>';
        }
        
        messageDiv.innerHTML = roleBadge + contentHtml;
        wrapper.appendChild(messageDiv);
        
        // If this is a user message, create the node progress container immediately
        if (role === 'user') {
            const progressContainer = document.createElement('div');
            progressContainer.className = 'node-progress-container';
            progressContainer.style.display = 'none'; // Hide until first node starts
            wrapper.appendChild(progressContainer);
        }
        
        // Removed: Raw Table and Prompt Monitor from appendMessage
        // These are now shown above the response via displayNodeData
        
        historyEl.appendChild(wrapper);
        historyEl.scrollTop = historyEl.scrollHeight;
    }

    // ====================================================================================
    // PHASE 4: Smart Markdown Rendering with Buffering
    // ====================================================================================
    
    let currentTypingId = null;
    
    function appendStreamingChunk(messageId, chunk, type) {
        const messageEl = document.getElementById(messageId);
        if (!messageEl) return;

        let targetEl = null;
        if (type === 'response') {
            targetEl = messageEl.querySelector('.markdown-body');
        } else if (type === 'prompt_monitor') {
            targetEl = messageEl.querySelector('.prompt-monitor-content');
        }

        if (targetEl) {
            // Show typing indicator on first chunk
            if (!currentTypingId && type === 'response') {
                currentTypingId = showTypingIndicator(messageId);
            }
            
            // Store accumulated text in a data attribute to avoid reading typing indicator text
            if (!targetEl.dataset.accumulatedText) {
                targetEl.dataset.accumulatedText = '';
            }
            targetEl.dataset.accumulatedText += chunk;
            
            // Re-render markdown (throttle to avoid too frequent updates)
            if (type === 'response' && typeof marked !== 'undefined') {
                // Initialize render counter
                if (!targetEl._renderCount) targetEl._renderCount = 0;
                targetEl._renderCount++;
                
                // Get accumulated text from data attribute (excludes typing indicator)
                const fullText = targetEl.dataset.accumulatedText || '';
                
                // Detect if we're in middle of a table or code block
                const inCodeBlock = (fullText.split('```').length - 1) % 2 === 1;
                const inTable = fullText.includes('|') && fullText.lastIndexOf('\n\n') < fullText.lastIndexOf('|');
                
                // Re-render every 3 chunks, or if chunk is large, or if NOT in special structure
                const shouldRender = !inCodeBlock && !inTable && (chunk.length > 100 || targetEl._renderCount % 3 === 0);
                
                if (shouldRender) {
                    requestAnimationFrame(() => {
                        try {
                            // Keep typing indicator, only update content after it
                            const typingIndicator = targetEl.querySelector('.typing-indicator');
                            const parsedHtml = marked.parse(fullText);
                            if (typingIndicator) {
                                targetEl.innerHTML = '';
                                targetEl.appendChild(typingIndicator);
                                const contentDiv = document.createElement('div');
                                contentDiv.innerHTML = parsedHtml;
                                targetEl.appendChild(contentDiv);
                            } else {
                                targetEl.innerHTML = parsedHtml;
                            }
                        } catch (e) {
                            // If markdown parsing fails, keep as text
                            console.warn('Markdown parse error during streaming:', e);
                        }
                    });
                }
            } else if (type === 'prompt_monitor' && typeof marked !== 'undefined') {
                if (!targetEl._renderCount) targetEl._renderCount = 0;
                targetEl._renderCount++;
                
                const fullText = targetEl.dataset.accumulatedText || '';
                
                if (chunk.length > 100 || targetEl._renderCount % 3 === 0) {
                    requestAnimationFrame(() => {
                        try {
                            targetEl.innerHTML = marked.parse(fullText);
                        } catch (e) {
                            targetEl.innerHTML = '<pre class="small text-muted">' + escapeHtml(fullText) + '</pre>';
                        }
                    });
                }
            }
            
            // Smart auto-scroll
            smoothScrollToBottom();
        }
    }

    function finalizeStreamingMessage(messageId, result) {
        const messageEl = document.getElementById(messageId);
        if (!messageEl) return;
        
        // Hide typing indicator
        if (currentTypingId) {
            hideTypingIndicator(currentTypingId);
            currentTypingId = null;
        }

        // Final markdown render - always render at the end to ensure proper formatting
        const responseEl = messageEl.querySelector('.markdown-body');
        if (responseEl && typeof marked !== 'undefined') {
            try {
                // Get the accumulated text from data attribute (excludes typing indicator text)
                let fullText = responseEl.dataset.accumulatedText || '';
                
                // FALLBACK: For knowledge questions or non-streamed responses, use final_output.response
                if (!fullText && result && result.final_output && result.final_output.response) {
                    fullText = result.final_output.response;
                    console.log('[finalizeStreamingMessage] No accumulated text, using final_output.response:', fullText.substring(0, 100));
                }
                
                // Parse and render markdown (final pass ensures everything is correct)
                requestAnimationFrame(() => {
                    try {
                        responseEl.innerHTML = marked.parse(fullText);
                    } catch (e) {
                        console.error('Final markdown render error:', e);
                        responseEl.innerHTML = '<pre>' + escapeHtml(fullText) + '</pre>';
                    }
                    // Clear the data attribute after final render
                    delete responseEl.dataset.accumulatedText;
                });
            } catch (e) {
                console.error('Final markdown render error:', e);
                // Fallback to escaped text if parsing fails
                responseEl.innerHTML = '<pre>' + escapeHtml(responseEl.textContent) + '</pre>';
            }
        }

        // Removed: Raw Table and Prompt Monitor from finalizeStreamingMessage
        // These are now shown above the response via displayNodeData
    }

    let awaitingClarification = false;
    let currentSessionId = sessionId;

    // Function to start a new chat session
    function startNewChat() {
        // Generate new session ID
        const newSessionId = 'sess-' + Math.random().toString(36).slice(2, 10);
        
        // Clear localStorage
        localStorage.removeItem('agent_session_id');
        localStorage.removeItem('agentSessionId');
        
        // Store new session ID
        localStorage.setItem('agent_session_id', newSessionId);
        
        // Update session variables
        sessionId = newSessionId;
        currentSessionId = newSessionId;
        
        // Clear chat history
        historyEl.innerHTML = '';
        
        // Reset streaming state
        accumulatedText = {
            planner: '',
            evaluator: '',
            end_response: '',
            end_prompt_monitor: ''
        };
        currentResponseId = null;
        currentPromptMonitorId = null;
        resetNodeProgressStatus();
        awaitingClarification = false;
        
        // Rejoin socket session if connected
        if (socket && socket.connected) {
            socket.emit('join_session', { session_id: newSessionId });
            console.log('Started new chat session:', newSessionId);
        }
        
        // Optionally delete old session file on server (optional cleanup)
        // This is handled automatically when a new session ID is used
        
        // Show confirmation
        const welcomeMsg = document.createElement('div');
        welcomeMsg.className = 'alert alert-info mb-2';
        welcomeMsg.innerHTML = '<i class="bi bi-info-circle"></i> <strong>New Chat Started</strong> - Previous conversation history cleared.';
        historyEl.appendChild(welcomeMsg);
        smoothScrollToBottom();
        
        // Remove welcome message after 3 seconds
        setTimeout(() => {
            if (welcomeMsg.parentNode) {
                welcomeMsg.remove();
            }
        }, 3000);
    }

    function sendQuery() {
        const q = inputEl.value.trim();
        if (!q) return;
        appendMessage('user', q);
        inputEl.value = '';
        $('#sendBtn').prop('disabled', true);

        // Reset streaming state
        accumulatedText = {
            planner: '',
            evaluator: '',
            end_response: '',
            end_prompt_monitor: ''
        };
        currentStreamingNode = null;
        currentTypingId = null;

        // Create placeholder for agent response
        messageCounter++;
        currentResponseId = 'msg-' + messageCounter;
        currentPromptMonitorId = 'prompt-' + messageCounter;
        
        const wrapper = document.createElement('div');
        wrapper.className = 'mb-3 message-fade-in';
        const messageDiv = document.createElement('div');
        messageDiv.id = currentResponseId;
        messageDiv.className = 'chat-message agent';
        messageDiv.innerHTML = '<span class="badge bg-success me-2">Agent</span><div class="markdown-body"></div>';
        wrapper.appendChild(messageDiv);
        historyEl.appendChild(wrapper);
        
        // Clear previous node data displays for this response
        // (We'll track by responseId, so old displays won't interfere)
        // nodeDataDisplays will be keyed by responseId_nodeName, so they're naturally scoped
        
        // Reset and initialize node progress status
        resetNodeProgressStatus();
        
        // Smooth scroll to new message
        smoothScrollToBottom();

        // Use WebSocket if available, otherwise fall back to HTTP
        if (socketAvailable && socket && socket.connected) {
            // Use WebSocket streaming
            const requestData = {
                query: q,
                session_id: currentSessionId,
                token: templateToken || sessionStorage.getItem('mcp_token') || ''
            };

            if (awaitingClarification) {
                requestData.user_clarification = q;
                awaitingClarification = false;
                inputEl.placeholder = 'Ask a question or provide a follow-up...';
            }

            socket.emit('agent:query', requestData);
        } else {
            // Fall back to HTTP POST
            const requestArgs = {
                query: q,
                session_id: currentSessionId,
                user_id: '{{ user.user_id | default("anonymous") }}'
            };

            if (awaitingClarification) {
                requestArgs.user_clarification = q;
                awaitingClarification = false;
                inputEl.placeholder = 'Ask a question or provide a follow-up...';
            }

            API.post('/api/tools/execute', {
                tool: 'parquet_agent',
                arguments: requestArgs
            }).done(function(resp) {
            console.log('API Response:', resp);
            const result = (resp && resp.result) ? resp.result : resp;
            console.log('Result:', result);
            
            // Update session ID if provided
            if (result.session_id) {
                currentSessionId = result.session_id;
                localStorage.setItem('agentSessionId', currentSessionId);
            }
            
            // Check if agent needs clarification
            if (result.control === 'wait_for_user' && result.clarify_prompt) {
                // Agent is asking for clarification
                console.log('Clarification needed:', result.clarify_prompt);
                appendMessage('agent', result.clarify_prompt);
                awaitingClarification = true;
                inputEl.placeholder = 'Provide clarification...';
            } else {
                // Normal response
                const finalOut = (result && result.final_output) ? result.final_output : {};
                const answer = finalOut.response || JSON.stringify(result).slice(0, 1000);
                console.log('=== AGENT COMPLETE DEBUG ===');
                console.log('Full Result:', result);
                console.log('Final Output:', finalOut);
                console.log('Answer extracted:', answer);
                console.log('Answer length:', answer ? answer.length : 0);
                console.log('===========================');
                
                // Update the placeholder message with final result
                if (currentResponseId) {
                    // If we have a streaming placeholder, finalize it
                    finalizeStreamingMessage(currentResponseId, result);
                } else {
                    // Otherwise use regular appendMessage (which handles markdown)
                    appendMessage('agent', answer, result);
                }
                awaitingClarification = false;
                inputEl.placeholder = 'Ask a question or provide a follow-up...';
            }
        }).fail(function(xhr) {
            const err = (xhr.responseJSON && xhr.responseJSON.error) ? xhr.responseJSON.error : ('HTTP ' + xhr.status);
            
            // Hide loading states
            
            // Show error in node progress status
            updateNodeProgressStatus();
            
            // Show error message
            if (currentResponseId) {
                const msgEl = document.getElementById(currentResponseId);
                if (msgEl) {
                    msgEl.classList.add('error-message');
                    const markdownBody = msgEl.querySelector('.markdown-body');
                    if (markdownBody) {
                        markdownBody.innerHTML = '<i class="bi bi-exclamation-triangle"></i> Error: ' + escapeHtml(err);
                    }
                }
            } else {
                appendMessage('agent', 'Error: ' + err);
            }
            awaitingClarification = false;
            inputEl.placeholder = 'Ask a question or provide a follow-up...';
        }).always(function() {
            $('#sendBtn').prop('disabled', false);
            
            // Clean up state variables
            currentResponseId = null;
            currentPromptMonitorId = null;
            resetNodeProgressStatus();
            currentTypingId = null;
        });
        }
    }

    // Initialize node progress status on page load
    resetNodeProgressStatus();
    
    // Event listeners
    sendBtn.addEventListener('click', sendQuery);
    inputEl.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') sendQuery();
    });
    
    // New Chat button
    const newChatBtn = document.getElementById('newChatBtn');
    if (newChatBtn) {
        newChatBtn.addEventListener('click', function() {
            if (confirm('Start a new chat? This will clear the current conversation history.')) {
                startNewChat();
            }
        });
    }
})();
</script>
{% endblock %}
